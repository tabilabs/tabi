// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tabi/captains/v1/captains.proto

package types

import (
	fmt "fmt"
	cosmos_proto "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	gogoproto "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

var E_GoprotoEnumPrefix = gogoproto.E_GoprotoEnumPrefix

var E_GoprotoEnumStringer = gogoproto.E_GoprotoEnumStringer

var E_EnumStringer = gogoproto.E_EnumStringer

var E_EnumCustomname = gogoproto.E_EnumCustomname

var E_Enumdecl = gogoproto.E_Enumdecl

var E_EnumvalueCustomname = gogoproto.E_EnumvalueCustomname

var E_GoprotoGettersAll = gogoproto.E_GoprotoGettersAll

var E_GoprotoEnumPrefixAll = gogoproto.E_GoprotoEnumPrefixAll

var E_GoprotoStringerAll = gogoproto.E_GoprotoStringerAll

var E_VerboseEqualAll = gogoproto.E_VerboseEqualAll

var E_FaceAll = gogoproto.E_FaceAll

var E_GostringAll = gogoproto.E_GostringAll

var E_PopulateAll = gogoproto.E_PopulateAll

var E_StringerAll = gogoproto.E_StringerAll

var E_OnlyoneAll = gogoproto.E_OnlyoneAll

var E_EqualAll = gogoproto.E_EqualAll

var E_DescriptionAll = gogoproto.E_DescriptionAll

var E_TestgenAll = gogoproto.E_TestgenAll

var E_BenchgenAll = gogoproto.E_BenchgenAll

var E_MarshalerAll = gogoproto.E_MarshalerAll

var E_UnmarshalerAll = gogoproto.E_UnmarshalerAll

var E_StableMarshalerAll = gogoproto.E_StableMarshalerAll

var E_SizerAll = gogoproto.E_SizerAll

var E_GoprotoEnumStringerAll = gogoproto.E_GoprotoEnumStringerAll

var E_EnumStringerAll = gogoproto.E_EnumStringerAll

var E_UnsafeMarshalerAll = gogoproto.E_UnsafeMarshalerAll

var E_UnsafeUnmarshalerAll = gogoproto.E_UnsafeUnmarshalerAll

var E_GoprotoExtensionsMapAll = gogoproto.E_GoprotoExtensionsMapAll

var E_GoprotoUnrecognizedAll = gogoproto.E_GoprotoUnrecognizedAll

var E_GogoprotoImport = gogoproto.E_GogoprotoImport

var E_ProtosizerAll = gogoproto.E_ProtosizerAll

var E_CompareAll = gogoproto.E_CompareAll

var E_TypedeclAll = gogoproto.E_TypedeclAll

var E_EnumdeclAll = gogoproto.E_EnumdeclAll

var E_GoprotoRegistration = gogoproto.E_GoprotoRegistration

var E_MessagenameAll = gogoproto.E_MessagenameAll

var E_GoprotoSizecacheAll = gogoproto.E_GoprotoSizecacheAll

var E_GoprotoUnkeyedAll = gogoproto.E_GoprotoUnkeyedAll

var E_GoprotoGetters = gogoproto.E_GoprotoGetters

var E_GoprotoStringer = gogoproto.E_GoprotoStringer

var E_VerboseEqual = gogoproto.E_VerboseEqual

var E_Face = gogoproto.E_Face

var E_Gostring = gogoproto.E_Gostring

var E_Populate = gogoproto.E_Populate

var E_Stringer = gogoproto.E_Stringer

var E_Onlyone = gogoproto.E_Onlyone

var E_Equal = gogoproto.E_Equal

var E_Description = gogoproto.E_Description

var E_Testgen = gogoproto.E_Testgen

var E_Benchgen = gogoproto.E_Benchgen

var E_Marshaler = gogoproto.E_Marshaler

var E_Unmarshaler = gogoproto.E_Unmarshaler

var E_StableMarshaler = gogoproto.E_StableMarshaler

var E_Sizer = gogoproto.E_Sizer

var E_UnsafeMarshaler = gogoproto.E_UnsafeMarshaler

var E_UnsafeUnmarshaler = gogoproto.E_UnsafeUnmarshaler

var E_GoprotoExtensionsMap = gogoproto.E_GoprotoExtensionsMap

var E_GoprotoUnrecognized = gogoproto.E_GoprotoUnrecognized

var E_Protosizer = gogoproto.E_Protosizer

var E_Compare = gogoproto.E_Compare

var E_Typedecl = gogoproto.E_Typedecl

var E_Messagename = gogoproto.E_Messagename

var E_GoprotoSizecache = gogoproto.E_GoprotoSizecache

var E_GoprotoUnkeyed = gogoproto.E_GoprotoUnkeyed

var E_Nullable = gogoproto.E_Nullable

var E_Embed = gogoproto.E_Embed

var E_Customtype = gogoproto.E_Customtype

var E_Customname = gogoproto.E_Customname

var E_Jsontag = gogoproto.E_Jsontag

var E_Moretags = gogoproto.E_Moretags

var E_Casttype = gogoproto.E_Casttype

var E_Castkey = gogoproto.E_Castkey

var E_Castvalue = gogoproto.E_Castvalue

var E_Stdtime = gogoproto.E_Stdtime

var E_Stdduration = gogoproto.E_Stdduration

var E_Wktpointer = gogoproto.E_Wktpointer

var E_Castrepeated = gogoproto.E_Castrepeated

// InterfaceDescriptor from public import cosmos_proto/cosmos.proto
type InterfaceDescriptor = cosmos_proto.InterfaceDescriptor

// ScalarDescriptor from public import cosmos_proto/cosmos.proto
type ScalarDescriptor = cosmos_proto.ScalarDescriptor

// ScalarType from public import cosmos_proto/cosmos.proto
type ScalarType = cosmos_proto.ScalarType

var ScalarType_name = cosmos_proto.ScalarType_name
var ScalarType_value = cosmos_proto.ScalarType_value

const ScalarType_SCALAR_TYPE_UNSPECIFIED = ScalarType(cosmos_proto.ScalarType_SCALAR_TYPE_UNSPECIFIED)
const ScalarType_SCALAR_TYPE_STRING = ScalarType(cosmos_proto.ScalarType_SCALAR_TYPE_STRING)
const ScalarType_SCALAR_TYPE_BYTES = ScalarType(cosmos_proto.ScalarType_SCALAR_TYPE_BYTES)

var E_ImplementsInterface = cosmos_proto.E_ImplementsInterface

var E_AcceptsInterface = cosmos_proto.E_AcceptsInterface

var E_Scalar = cosmos_proto.E_Scalar

var E_DeclareInterface = cosmos_proto.E_DeclareInterface

var E_DeclareScalar = cosmos_proto.E_DeclareScalar

// Params defines captains module's parameters
type Params struct {
	// captains_total_count defines the total count of the captains
	CaptainsTotalCount uint64 `protobuf:"varint,1,opt,name=captains_total_count,json=captainsTotalCount,proto3" json:"captains_total_count,omitempty"`
	// minimum_power_on_period defines the minimum period for a captain to be powered on
	MinimumPowerOnPeriod uint64 `protobuf:"varint,2,opt,name=minimum_power_on_period,json=minimumPowerOnPeriod,proto3" json:"minimum_power_on_period,omitempty"`
	// maximum_power_on_period defines the maximum period for a captain to be powered on
	MaximumPowerOnPeriod uint64 `protobuf:"varint,3,opt,name=maximum_power_on_period,json=maximumPowerOnPeriod,proto3" json:"maximum_power_on_period,omitempty"`
	// captains_constant is a fixed constant for reward calculation
	CaptainsConstant github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=captains_constant,json=captainsConstant,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"captains_constant"`
	// halving_era_coefficient defines the halving era coefficient
	HalvingEraCoefficient github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=halving_era_coefficient,json=halvingEraCoefficient,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"halving_era_coefficient"`
	// tech_progress_coefficient_cardinality defines the tech progress coefficient cardinality.
	TechProgressCoefficientCardinality github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=tech_progress_coefficient_cardinality,json=techProgressCoefficientCardinality,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"tech_progress_coefficient_cardinality"`
	// current_sale_level defines the current level for sale.
	CurrentSaleLevel uint64 `protobuf:"varint,7,opt,name=current_sale_level,json=currentSaleLevel,proto3" json:"current_sale_level,omitempty"`
	// authorized_members authorized members list
	AuthorizedMembers []string `protobuf:"bytes,8,rep,name=authorized_members,json=authorizedMembers,proto3" json:"authorized_members,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetCaptainsTotalCount() uint64 {
	if m != nil {
		return m.CaptainsTotalCount
	}
	return 0
}

func (m *Params) GetMinimumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MinimumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetMaximumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MaximumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetCurrentSaleLevel() uint64 {
	if m != nil {
		return m.CurrentSaleLevel
	}
	return 0
}

func (m *Params) GetAuthorizedMembers() []string {
	if m != nil {
		return m.AuthorizedMembers
	}
	return nil
}

// Division defines the division a node belongs to.
type Division struct {
	// id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// level defines the level of the node.
	Level uint64 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	// initial_supply defines the initial supply of the node in the division.
	InitialSupply uint64 `protobuf:"varint,3,opt,name=initial_supply,json=initialSupply,proto3" json:"initial_supply,omitempty"`
	// sold_count defines the total count of the node in the division.
	SoldCount uint64 `protobuf:"varint,4,opt,name=sold_count,json=soldCount,proto3" json:"sold_count,omitempty"`
	// total_count defines the supply count of nodes in the division.
	TotalCount uint64 `protobuf:"varint,5,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// computing_power_lower_bound defines the low bound of computing power in the division.
	ComputingPowerLowerBound uint64 `protobuf:"varint,6,opt,name=computing_power_lower_bound,json=computingPowerLowerBound,proto3" json:"computing_power_lower_bound,omitempty"`
	// computing_power_upper_bound defines the upper bound of computing power in the division.
	ComputingPowerUpperBound uint64 `protobuf:"varint,7,opt,name=computing_power_upper_bound,json=computingPowerUpperBound,proto3" json:"computing_power_upper_bound,omitempty"`
}

func (m *Division) Reset()         { *m = Division{} }
func (m *Division) String() string { return proto.CompactTextString(m) }
func (*Division) ProtoMessage()    {}
func (*Division) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{1}
}
func (m *Division) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Division) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Division.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Division) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Division.Merge(m, src)
}
func (m *Division) XXX_Size() int {
	return m.Size()
}
func (m *Division) XXX_DiscardUnknown() {
	xxx_messageInfo_Division.DiscardUnknown(m)
}

var xxx_messageInfo_Division proto.InternalMessageInfo

func (m *Division) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Division) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Division) GetInitialSupply() uint64 {
	if m != nil {
		return m.InitialSupply
	}
	return 0
}

func (m *Division) GetSoldCount() uint64 {
	if m != nil {
		return m.SoldCount
	}
	return 0
}

func (m *Division) GetTotalCount() uint64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *Division) GetComputingPowerLowerBound() uint64 {
	if m != nil {
		return m.ComputingPowerLowerBound
	}
	return 0
}

func (m *Division) GetComputingPowerUpperBound() uint64 {
	if m != nil {
		return m.ComputingPowerUpperBound
	}
	return 0
}

// Node defines the node
type Node struct {
	// id
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// division_id
	DivisionId string `protobuf:"bytes,2,opt,name=division_id,json=divisionId,proto3" json:"division_id,omitempty"`
	// owner
	Owner string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	// computing_power
	ComputingPower uint64 `protobuf:"varint,4,opt,name=computing_power,json=computingPower,proto3" json:"computing_power,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetDivisionId() string {
	if m != nil {
		return m.DivisionId
	}
	return ""
}

func (m *Node) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Node) GetComputingPower() uint64 {
	if m != nil {
		return m.ComputingPower
	}
	return 0
}

// BaseState defines the state of the epoch
type BaseState struct {
	// epoch_id id of the epoch
	EpochId uint64 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// is_epoch_end whether the epoch is ended
	IsEpochEnd bool `protobuf:"varint,2,opt,name=is_epoch_end,json=isEpochEnd,proto3" json:"is_epoch_end,omitempty"`
	// next_node_sequence the next node sequence
	NextNodeSequence uint64 `protobuf:"varint,3,opt,name=next_node_sequence,json=nextNodeSequence,proto3" json:"next_node_sequence,omitempty"`
	// global_claimed_emission global claimed emission
	GlobalClaimedEmission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=global_claimed_emission,json=globalClaimedEmission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"global_claimed_emission"`
	// report_digest the digest of the report
	ReportDigest *ReportDigest `protobuf:"bytes,5,opt,name=report_digest,json=reportDigest,proto3" json:"report_digest,omitempty"`
	// is_stand_by is in epoch stand_by phase
	IsStandBy bool `protobuf:"varint,6,opt,name=is_stand_by,json=isStandBy,proto3" json:"is_stand_by,omitempty"`
}

func (m *BaseState) Reset()         { *m = BaseState{} }
func (m *BaseState) String() string { return proto.CompactTextString(m) }
func (*BaseState) ProtoMessage()    {}
func (*BaseState) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{3}
}
func (m *BaseState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseState.Merge(m, src)
}
func (m *BaseState) XXX_Size() int {
	return m.Size()
}
func (m *BaseState) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseState.DiscardUnknown(m)
}

var xxx_messageInfo_BaseState proto.InternalMessageInfo

func (m *BaseState) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *BaseState) GetIsEpochEnd() bool {
	if m != nil {
		return m.IsEpochEnd
	}
	return false
}

func (m *BaseState) GetNextNodeSequence() uint64 {
	if m != nil {
		return m.NextNodeSequence
	}
	return 0
}

func (m *BaseState) GetReportDigest() *ReportDigest {
	if m != nil {
		return m.ReportDigest
	}
	return nil
}

func (m *BaseState) GetIsStandBy() bool {
	if m != nil {
		return m.IsStandBy
	}
	return false
}

// EpochEmission
type EpochEmission struct {
	// epoch_id
	EpochId uint64 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// emission
	Emission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=emission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"emission"`
}

func (m *EpochEmission) Reset()         { *m = EpochEmission{} }
func (m *EpochEmission) String() string { return proto.CompactTextString(m) }
func (*EpochEmission) ProtoMessage()    {}
func (*EpochEmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{4}
}
func (m *EpochEmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochEmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochEmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochEmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochEmission.Merge(m, src)
}
func (m *EpochEmission) XXX_Size() int {
	return m.Size()
}
func (m *EpochEmission) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochEmission.DiscardUnknown(m)
}

var xxx_messageInfo_EpochEmission proto.InternalMessageInfo

func (m *EpochEmission) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

// NodeClaimedEmission
type NodeClaimedEmission struct {
	// node_id
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// emission
	Emission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=emission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"emission"`
}

func (m *NodeClaimedEmission) Reset()         { *m = NodeClaimedEmission{} }
func (m *NodeClaimedEmission) String() string { return proto.CompactTextString(m) }
func (*NodeClaimedEmission) ProtoMessage()    {}
func (*NodeClaimedEmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{5}
}
func (m *NodeClaimedEmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeClaimedEmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeClaimedEmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeClaimedEmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeClaimedEmission.Merge(m, src)
}
func (m *NodeClaimedEmission) XXX_Size() int {
	return m.Size()
}
func (m *NodeClaimedEmission) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeClaimedEmission.DiscardUnknown(m)
}

var xxx_messageInfo_NodeClaimedEmission proto.InternalMessageInfo

func (m *NodeClaimedEmission) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

// ClaimableComputingPower
type ClaimableComputingPower struct {
	// amount
	Amount uint64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// owner
	Owner string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *ClaimableComputingPower) Reset()         { *m = ClaimableComputingPower{} }
func (m *ClaimableComputingPower) String() string { return proto.CompactTextString(m) }
func (*ClaimableComputingPower) ProtoMessage()    {}
func (*ClaimableComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{6}
}
func (m *ClaimableComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimableComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimableComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimableComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimableComputingPower.Merge(m, src)
}
func (m *ClaimableComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *ClaimableComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimableComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimableComputingPower proto.InternalMessageInfo

func (m *ClaimableComputingPower) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ClaimableComputingPower) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

// NodeCumulativeEmission
type NodeCumulativeEmission struct {
	// node_id
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// epoch_id
	EpochId uint64 `protobuf:"varint,2,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// emission
	Emission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=emission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"emission"`
}

func (m *NodeCumulativeEmission) Reset()         { *m = NodeCumulativeEmission{} }
func (m *NodeCumulativeEmission) String() string { return proto.CompactTextString(m) }
func (*NodeCumulativeEmission) ProtoMessage()    {}
func (*NodeCumulativeEmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{7}
}
func (m *NodeCumulativeEmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCumulativeEmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCumulativeEmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCumulativeEmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCumulativeEmission.Merge(m, src)
}
func (m *NodeCumulativeEmission) XXX_Size() int {
	return m.Size()
}
func (m *NodeCumulativeEmission) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCumulativeEmission.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCumulativeEmission proto.InternalMessageInfo

func (m *NodeCumulativeEmission) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *NodeCumulativeEmission) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

// GlobalComputingPower
type GlobalComputingPower struct {
	// epoch_id
	EpochId uint64 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// amount
	Amount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *GlobalComputingPower) Reset()         { *m = GlobalComputingPower{} }
func (m *GlobalComputingPower) String() string { return proto.CompactTextString(m) }
func (*GlobalComputingPower) ProtoMessage()    {}
func (*GlobalComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{8}
}
func (m *GlobalComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalComputingPower.Merge(m, src)
}
func (m *GlobalComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *GlobalComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalComputingPower proto.InternalMessageInfo

func (m *GlobalComputingPower) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

// NodesComputingPower
type NodesComputingPower struct {
	// node_id
	NodeId string `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// epoch_id
	EpochId uint64 `protobuf:"varint,2,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// amount
	Amount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *NodesComputingPower) Reset()         { *m = NodesComputingPower{} }
func (m *NodesComputingPower) String() string { return proto.CompactTextString(m) }
func (*NodesComputingPower) ProtoMessage()    {}
func (*NodesComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{9}
}
func (m *NodesComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodesComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodesComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesComputingPower.Merge(m, src)
}
func (m *NodesComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *NodesComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_NodesComputingPower proto.InternalMessageInfo

func (m *NodesComputingPower) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *NodesComputingPower) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

// GlobalPledge
type GlobalPledge struct {
	// epoch_id
	EpochId uint64 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// amount
	Amount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *GlobalPledge) Reset()         { *m = GlobalPledge{} }
func (m *GlobalPledge) String() string { return proto.CompactTextString(m) }
func (*GlobalPledge) ProtoMessage()    {}
func (*GlobalPledge) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{10}
}
func (m *GlobalPledge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalPledge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalPledge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalPledge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalPledge.Merge(m, src)
}
func (m *GlobalPledge) XXX_Size() int {
	return m.Size()
}
func (m *GlobalPledge) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalPledge.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalPledge proto.InternalMessageInfo

func (m *GlobalPledge) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

// OwnerPledge
type OwnerPledge struct {
	// owner
	Owner string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	// epoch_id
	EpochId uint64 `protobuf:"varint,2,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// amount
	Amount github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *OwnerPledge) Reset()         { *m = OwnerPledge{} }
func (m *OwnerPledge) String() string { return proto.CompactTextString(m) }
func (*OwnerPledge) ProtoMessage()    {}
func (*OwnerPledge) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{11}
}
func (m *OwnerPledge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerPledge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerPledge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerPledge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerPledge.Merge(m, src)
}
func (m *OwnerPledge) XXX_Size() int {
	return m.Size()
}
func (m *OwnerPledge) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerPledge.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerPledge proto.InternalMessageInfo

func (m *OwnerPledge) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *OwnerPledge) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "tabi.captains.v1.Params")
	proto.RegisterType((*Division)(nil), "tabi.captains.v1.Division")
	proto.RegisterType((*Node)(nil), "tabi.captains.v1.Node")
	proto.RegisterType((*BaseState)(nil), "tabi.captains.v1.BaseState")
	proto.RegisterType((*EpochEmission)(nil), "tabi.captains.v1.EpochEmission")
	proto.RegisterType((*NodeClaimedEmission)(nil), "tabi.captains.v1.NodeClaimedEmission")
	proto.RegisterType((*ClaimableComputingPower)(nil), "tabi.captains.v1.ClaimableComputingPower")
	proto.RegisterType((*NodeCumulativeEmission)(nil), "tabi.captains.v1.NodeCumulativeEmission")
	proto.RegisterType((*GlobalComputingPower)(nil), "tabi.captains.v1.GlobalComputingPower")
	proto.RegisterType((*NodesComputingPower)(nil), "tabi.captains.v1.NodesComputingPower")
	proto.RegisterType((*GlobalPledge)(nil), "tabi.captains.v1.GlobalPledge")
	proto.RegisterType((*OwnerPledge)(nil), "tabi.captains.v1.OwnerPledge")
}

func init() { proto.RegisterFile("tabi/captains/v1/captains.proto", fileDescriptor_35d5085f64c624e4) }

var fileDescriptor_35d5085f64c624e4 = []byte{
	// 967 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xce, 0x3a, 0x4e, 0x62, 0xbf, 0x4e, 0x42, 0x3a, 0xb8, 0x8d, 0x5b, 0x54, 0x3b, 0xb2, 0x54,
	0x08, 0x12, 0xb1, 0x29, 0x88, 0x1b, 0x1c, 0xb0, 0x13, 0xa1, 0x4a, 0x85, 0x5a, 0xeb, 0x22, 0x21,
	0x2e, 0xa3, 0xf1, 0xce, 0xd4, 0x1e, 0xb1, 0x3b, 0xb3, 0xec, 0xcc, 0xba, 0x09, 0x17, 0x2e, 0x48,
	0x70, 0x83, 0x03, 0x9c, 0xb9, 0xf1, 0x0b, 0xfa, 0x23, 0x7a, 0x2c, 0x3d, 0x21, 0x0e, 0x15, 0x4a,
	0xfe, 0x04, 0x47, 0x34, 0x1f, 0x5e, 0x3b, 0x69, 0x28, 0x12, 0x72, 0x7b, 0x59, 0xef, 0xbc, 0xcf,
	0xfb, 0x35, 0xcf, 0xfb, 0xcc, 0x78, 0xa1, 0xa5, 0xc9, 0x88, 0x77, 0x23, 0x92, 0x6a, 0xc2, 0x85,
	0xea, 0x4e, 0x6f, 0x17, 0xef, 0x9d, 0x34, 0x93, 0x5a, 0xa2, 0x1d, 0xe3, 0xd0, 0x29, 0x8c, 0xd3,
	0xdb, 0x37, 0xea, 0x63, 0x39, 0x96, 0x16, 0xec, 0x9a, 0x37, 0xe7, 0x77, 0xe3, 0x7a, 0x24, 0x55,
	0x22, 0x15, 0x76, 0x80, 0x5b, 0x78, 0xe8, 0xe6, 0x73, 0x35, 0x32, 0x96, 0xca, 0x4c, 0x3b, 0xb8,
	0xfd, 0x77, 0x19, 0xd6, 0x07, 0x24, 0x23, 0x89, 0x42, 0xef, 0x42, 0x7d, 0xe6, 0x86, 0xb5, 0xd4,
	0x24, 0xc6, 0x91, 0xcc, 0x85, 0x6e, 0x04, 0x7b, 0xc1, 0x7e, 0x39, 0x44, 0x33, 0xec, 0xbe, 0x81,
	0xfa, 0x06, 0x41, 0x1f, 0xc0, 0x6e, 0xc2, 0x05, 0x4f, 0xf2, 0x04, 0xa7, 0xf2, 0x21, 0xcb, 0xb0,
	0x14, 0x38, 0x65, 0x19, 0x97, 0xb4, 0x51, 0xb2, 0x41, 0x75, 0x0f, 0x0f, 0x0c, 0x7a, 0x4f, 0x0c,
	0x2c, 0x66, 0xc3, 0xc8, 0xf1, 0xa5, 0x61, 0xab, 0x3e, 0xcc, 0xc1, 0xe7, 0xc3, 0x38, 0x5c, 0x29,
	0xfa, 0x8b, 0xa4, 0x50, 0x9a, 0x08, 0xdd, 0x28, 0xef, 0x05, 0xfb, 0xd5, 0xde, 0x87, 0x8f, 0x9f,
	0xb5, 0x56, 0xfe, 0x7c, 0xd6, 0x7a, 0x73, 0xcc, 0xf5, 0x24, 0x1f, 0x75, 0x22, 0x99, 0x78, 0x16,
	0xfc, 0xcf, 0x81, 0xa2, 0x5f, 0x75, 0xf5, 0x49, 0xca, 0x54, 0xe7, 0x90, 0x45, 0x4f, 0x1f, 0x1d,
	0x80, 0x27, 0xe9, 0x90, 0x45, 0xe1, 0xce, 0x2c, 0x6d, 0xdf, 0x67, 0x45, 0x1a, 0x76, 0x27, 0x24,
	0x9e, 0x72, 0x31, 0xc6, 0x2c, 0x23, 0x38, 0x92, 0xec, 0xc1, 0x03, 0x1e, 0x71, 0x26, 0x74, 0x63,
	0x6d, 0x09, 0x05, 0xaf, 0xfa, 0xe4, 0x47, 0x19, 0xe9, 0xcf, 0x53, 0xa3, 0x1f, 0x03, 0xb8, 0xa5,
	0x59, 0x34, 0x31, 0x63, 0x1c, 0x67, 0x4c, 0xa9, 0xc5, 0xc2, 0x38, 0x22, 0x19, 0xe5, 0x82, 0xc4,
	0x5c, 0x9f, 0x34, 0xd6, 0x97, 0xd0, 0x44, 0xdb, 0x94, 0x1a, 0xf8, 0x4a, 0x0b, 0x6d, 0xf4, 0xe7,
	0x75, 0xd0, 0x3b, 0x80, 0xa2, 0x3c, 0xcb, 0x4c, 0x79, 0x45, 0x62, 0x86, 0x63, 0x36, 0x65, 0x71,
	0x63, 0xc3, 0x0e, 0x69, 0xc7, 0x23, 0x43, 0x12, 0xb3, 0xbb, 0xc6, 0x8e, 0x0e, 0x00, 0x91, 0x5c,
	0x4f, 0x64, 0xc6, 0xbf, 0x61, 0x14, 0x27, 0x2c, 0x19, 0xb1, 0x4c, 0x35, 0x2a, 0x7b, 0xab, 0xfb,
	0xd5, 0xf0, 0xca, 0x1c, 0xf9, 0xd4, 0x01, 0xed, 0x5f, 0x4a, 0x50, 0x39, 0xe4, 0x53, 0xae, 0xb8,
	0x14, 0x68, 0x1b, 0x4a, 0x9c, 0x5a, 0xa9, 0x55, 0xc3, 0x12, 0xa7, 0xa8, 0x0e, 0x6b, 0xae, 0x98,
	0x13, 0x92, 0x5b, 0xa0, 0x5b, 0xb0, 0xcd, 0x05, 0xd7, 0x9c, 0xc4, 0x58, 0xe5, 0x69, 0x1a, 0x9f,
	0x78, 0xc1, 0x6c, 0x79, 0xeb, 0xd0, 0x1a, 0xd1, 0x4d, 0x00, 0x25, 0x63, 0xea, 0xf5, 0x5b, 0xb6,
	0x2e, 0x55, 0x63, 0x71, 0xb2, 0x6d, 0x41, 0x6d, 0x51, 0xdf, 0x6b, 0x16, 0x07, 0x3d, 0xd7, 0xf5,
	0x47, 0xf0, 0x46, 0x24, 0x93, 0x34, 0xd7, 0x46, 0x00, 0x4e, 0xa2, 0xb1, 0x7d, 0x8e, 0x64, 0x2e,
	0xa8, 0x65, 0xbf, 0x1c, 0x36, 0x0a, 0x17, 0x2b, 0xd3, 0xbb, 0xe6, 0xd1, 0x33, 0xf8, 0x65, 0xe1,
	0x79, 0x9a, 0x16, 0xe1, 0x1b, 0x97, 0x85, 0x7f, 0x6e, 0x1c, 0x6c, 0x78, 0x7b, 0x0a, 0xe5, 0xcf,
	0x24, 0x65, 0xcf, 0x51, 0xd2, 0x82, 0x1a, 0xf5, 0x74, 0x61, 0xee, 0x4e, 0x58, 0x35, 0x84, 0x99,
	0xe9, 0x8e, 0xe5, 0x4c, 0x3e, 0x14, 0x2c, 0xb3, 0xa4, 0x54, 0x43, 0xb7, 0x40, 0x6f, 0xc1, 0x6b,
	0x17, 0xba, 0xf1, 0x8c, 0x6c, 0x9f, 0xef, 0xa0, 0xfd, 0x7b, 0x09, 0xaa, 0x3d, 0xa2, 0xd8, 0x50,
	0x13, 0xcd, 0xd0, 0x75, 0xa8, 0xb0, 0x54, 0x46, 0x13, 0xec, 0x7b, 0x28, 0x87, 0x1b, 0x76, 0x7d,
	0x87, 0xa2, 0x3d, 0xd8, 0xe4, 0x0a, 0x3b, 0x94, 0x09, 0xd7, 0x49, 0x25, 0x04, 0xae, 0x8e, 0x8c,
	0xe9, 0x48, 0x50, 0xa3, 0x1b, 0xc1, 0x8e, 0x35, 0x16, 0x92, 0x32, 0xac, 0xd8, 0xd7, 0x39, 0x13,
	0x11, 0xf3, 0xb3, 0xda, 0x31, 0x88, 0xd9, 0xe0, 0xd0, 0xdb, 0xcd, 0x69, 0x1b, 0xc7, 0x72, 0x64,
	0x06, 0x12, 0x13, 0x9e, 0x30, 0x8a, 0x59, 0xc2, 0x95, 0xd9, 0xd4, 0x52, 0x8e, 0xf7, 0x55, 0x97,
	0xbc, 0xef, 0x72, 0x1f, 0xf9, 0xd4, 0xa8, 0x0f, 0x5b, 0xee, 0x26, 0xc4, 0x94, 0x8f, 0x99, 0x72,
	0x3a, 0xa8, 0xbd, 0xd7, 0xec, 0x5c, 0xbc, 0x73, 0x3b, 0xa1, 0x75, 0x3b, 0xb4, 0x5e, 0xe1, 0x66,
	0xb6, 0xb0, 0x42, 0x4d, 0xa8, 0x71, 0x85, 0xcd, 0xa5, 0x41, 0xf1, 0xc8, 0x9d, 0xcb, 0x4a, 0x58,
	0xe5, 0x6a, 0x68, 0x2c, 0xbd, 0x93, 0xf6, 0x77, 0x01, 0x6c, 0x39, 0x56, 0x66, 0x65, 0x5f, 0xc0,
	0xeb, 0x17, 0x50, 0x29, 0x36, 0x5e, 0x5a, 0xc2, 0xc6, 0x8b, 0x6c, 0xed, 0x1f, 0x02, 0x78, 0xdd,
	0x50, 0x7e, 0x91, 0x83, 0x5d, 0xd8, 0xb0, 0x23, 0x2a, 0x74, 0xb6, 0x6e, 0x96, 0x2f, 0xb5, 0x15,
	0x02, 0xbb, 0xb6, 0x0b, 0x32, 0x8a, 0x59, 0xff, 0x9c, 0x00, 0xd1, 0x35, 0x58, 0x27, 0xc9, 0xc2,
	0x5f, 0x8e, 0x5f, 0xa1, 0xce, 0x4c, 0xd7, 0xae, 0x93, 0xc6, 0xd3, 0x47, 0x07, 0x75, 0x9f, 0xfb,
	0x63, 0x4a, 0xcd, 0xf5, 0x35, 0xd4, 0x19, 0x17, 0x63, 0xaf, 0xf8, 0xf6, 0x6f, 0x01, 0x5c, 0xb3,
	0xbb, 0xcd, 0x93, 0x3c, 0x26, 0x9a, 0x4f, 0xd9, 0x7f, 0x6f, 0x78, 0x71, 0x2c, 0xa5, 0x7f, 0x1f,
	0xcb, 0xea, 0x52, 0xb9, 0xf8, 0x3e, 0x80, 0xfa, 0x27, 0x4e, 0x9c, 0xe7, 0x99, 0x78, 0x81, 0x48,
	0xee, 0x17, 0x24, 0x2d, 0x63, 0x2e, 0x3e, 0x57, 0xfb, 0x57, 0x2f, 0x10, 0x75, 0xa1, 0x91, 0xff,
	0xc3, 0xd7, 0xbc, 0xc3, 0xd5, 0x25, 0x76, 0xf8, 0x2d, 0x6c, 0x3a, 0xaa, 0x06, 0x31, 0xa3, 0x63,
	0xf6, 0xea, 0x29, 0xfa, 0x39, 0x80, 0xda, 0x3d, 0xa3, 0x2f, 0xdf, 0x40, 0x71, 0xdb, 0x06, 0x8b,
	0xb7, 0xed, 0xab, 0xe6, 0xa5, 0xd7, 0x7f, 0x7c, 0xda, 0x0c, 0x9e, 0x9c, 0x36, 0x83, 0xbf, 0x4e,
	0x9b, 0xc1, 0x4f, 0x67, 0xcd, 0x95, 0x27, 0x67, 0xcd, 0x95, 0x3f, 0xce, 0x9a, 0x2b, 0x5f, 0xbe,
	0xbd, 0x90, 0xd7, 0xdc, 0x69, 0x31, 0x19, 0x29, 0xfb, 0xd2, 0x3d, 0x9e, 0x7f, 0x0f, 0xda, 0xf4,
	0x83, 0x95, 0x41, 0x30, 0x5a, 0xb7, 0x1f, 0x84, 0xef, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x68,
	0x65, 0x4c, 0x00, 0x95, 0x0a, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorizedMembers) > 0 {
		for iNdEx := len(m.AuthorizedMembers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthorizedMembers[iNdEx])
			copy(dAtA[i:], m.AuthorizedMembers[iNdEx])
			i = encodeVarintCaptains(dAtA, i, uint64(len(m.AuthorizedMembers[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CurrentSaleLevel != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CurrentSaleLevel))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.TechProgressCoefficientCardinality.Size()
		i -= size
		if _, err := m.TechProgressCoefficientCardinality.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.HalvingEraCoefficient.Size()
		i -= size
		if _, err := m.HalvingEraCoefficient.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.CaptainsConstant.Size()
		i -= size
		if _, err := m.CaptainsConstant.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.MaximumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MaximumPowerOnPeriod))
		i--
		dAtA[i] = 0x18
	}
	if m.MinimumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MinimumPowerOnPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.CaptainsTotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CaptainsTotalCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Division) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Division) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Division) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPowerUpperBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerUpperBound))
		i--
		dAtA[i] = 0x38
	}
	if m.ComputingPowerLowerBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerLowerBound))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x28
	}
	if m.SoldCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.SoldCount))
		i--
		dAtA[i] = 0x20
	}
	if m.InitialSupply != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.InitialSupply))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPower != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DivisionId) > 0 {
		i -= len(m.DivisionId)
		copy(dAtA[i:], m.DivisionId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.DivisionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsStandBy {
		i--
		if m.IsStandBy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ReportDigest != nil {
		{
			size, err := m.ReportDigest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCaptains(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.GlobalClaimedEmission.Size()
		i -= size
		if _, err := m.GlobalClaimedEmission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.NextNodeSequence != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.NextNodeSequence))
		i--
		dAtA[i] = 0x18
	}
	if m.IsEpochEnd {
		i--
		if m.IsEpochEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochEmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochEmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochEmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Emission.Size()
		i -= size
		if _, err := m.Emission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeClaimedEmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeClaimedEmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeClaimedEmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Emission.Size()
		i -= size
		if _, err := m.Emission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimableComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimableComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimableComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeCumulativeEmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCumulativeEmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCumulativeEmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Emission.Size()
		i -= size
		if _, err := m.Emission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodesComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodesComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalPledge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalPledge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalPledge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OwnerPledge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerPledge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnerPledge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCaptains(dAtA []byte, offset int, v uint64) int {
	offset -= sovCaptains(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptainsTotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.CaptainsTotalCount))
	}
	if m.MinimumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MinimumPowerOnPeriod))
	}
	if m.MaximumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MaximumPowerOnPeriod))
	}
	l = m.CaptainsConstant.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.HalvingEraCoefficient.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.TechProgressCoefficientCardinality.Size()
	n += 1 + l + sovCaptains(uint64(l))
	if m.CurrentSaleLevel != 0 {
		n += 1 + sovCaptains(uint64(m.CurrentSaleLevel))
	}
	if len(m.AuthorizedMembers) > 0 {
		for _, s := range m.AuthorizedMembers {
			l = len(s)
			n += 1 + l + sovCaptains(uint64(l))
		}
	}
	return n
}

func (m *Division) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovCaptains(uint64(m.Level))
	}
	if m.InitialSupply != 0 {
		n += 1 + sovCaptains(uint64(m.InitialSupply))
	}
	if m.SoldCount != 0 {
		n += 1 + sovCaptains(uint64(m.SoldCount))
	}
	if m.TotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.TotalCount))
	}
	if m.ComputingPowerLowerBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerLowerBound))
	}
	if m.ComputingPowerUpperBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerUpperBound))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.DivisionId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.ComputingPower != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPower))
	}
	return n
}

func (m *BaseState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	if m.IsEpochEnd {
		n += 2
	}
	if m.NextNodeSequence != 0 {
		n += 1 + sovCaptains(uint64(m.NextNodeSequence))
	}
	l = m.GlobalClaimedEmission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	if m.ReportDigest != nil {
		l = m.ReportDigest.Size()
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.IsStandBy {
		n += 2
	}
	return n
}

func (m *EpochEmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Emission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *NodeClaimedEmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = m.Emission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *ClaimableComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovCaptains(uint64(m.Amount))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	return n
}

func (m *NodeCumulativeEmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Emission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *GlobalComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *NodesComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *GlobalPledge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *OwnerPledge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func sovCaptains(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCaptains(x uint64) (n int) {
	return sovCaptains(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsTotalCount", wireType)
			}
			m.CaptainsTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainsTotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumPowerOnPeriod", wireType)
			}
			m.MinimumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPowerOnPeriod", wireType)
			}
			m.MaximumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsConstant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CaptainsConstant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalvingEraCoefficient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HalvingEraCoefficient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechProgressCoefficientCardinality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TechProgressCoefficientCardinality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSaleLevel", wireType)
			}
			m.CurrentSaleLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSaleLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizedMembers = append(m.AuthorizedMembers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Division) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Division: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Division: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSupply", wireType)
			}
			m.InitialSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldCount", wireType)
			}
			m.SoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerLowerBound", wireType)
			}
			m.ComputingPowerLowerBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerLowerBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerUpperBound", wireType)
			}
			m.ComputingPowerUpperBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerUpperBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DivisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPower", wireType)
			}
			m.ComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEpochEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEpochEnd = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextNodeSequence", wireType)
			}
			m.NextNodeSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextNodeSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalClaimedEmission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GlobalClaimedEmission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDigest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportDigest == nil {
				m.ReportDigest = &ReportDigest{}
			}
			if err := m.ReportDigest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStandBy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStandBy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochEmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochEmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochEmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Emission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeClaimedEmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeClaimedEmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeClaimedEmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Emission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimableComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimableComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimableComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCumulativeEmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCumulativeEmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCumulativeEmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Emission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalPledge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalPledge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalPledge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerPledge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerPledge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerPledge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCaptains(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCaptains
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCaptains
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCaptains
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCaptains        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCaptains          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCaptains = fmt.Errorf("proto: unexpected end of group")
)
