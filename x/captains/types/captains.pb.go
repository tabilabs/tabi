// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tabi/captains/v1/captains.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines captains module's parameters
type Params struct {
	// captains_total_count defines the total count of the captains
	CaptainsTotalCount uint64 `protobuf:"varint,1,opt,name=captains_total_count,json=captainsTotalCount,proto3" json:"captains_total_count,omitempty"`
	// minimum_power_on_period defines the minimum period for a captain to be powered on
	MinimumPowerOnPeriod uint64 `protobuf:"varint,2,opt,name=minimum_power_on_period,json=minimumPowerOnPeriod,proto3" json:"minimum_power_on_period,omitempty"`
	// maximum_power_on_period defines the maximum period for a captain to be powered on
	MaximumPowerOnPeriod uint64 `protobuf:"varint,3,opt,name=maximum_power_on_period,json=maximumPowerOnPeriod,proto3" json:"maximum_power_on_period,omitempty"`
	// captains_constant is a fixed constant for reward calculation
	CaptainsConstant uint64 `protobuf:"varint,4,opt,name=captains_constant,json=captainsConstant,proto3" json:"captains_constant,omitempty"`
	// maximum_number_of_holdings defines the maximum number of captain nodes one account can hold.
	MaximumHoldingAmount uint64 `protobuf:"varint,5,opt,name=maximum_holding_amount,json=maximumHoldingAmount,proto3" json:"maximum_holding_amount,omitempty"`
	// halving_era defines the halving era coefficient
	HalvingEraCoefficient github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=halving_era_coefficient,json=halvingEraCoefficient,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"halving_era_coefficient"`
	// current_sale_level defines the current level for sale.
	CurrentSaleLevel uint64 `protobuf:"varint,7,opt,name=current_sale_level,json=currentSaleLevel,proto3" json:"current_sale_level,omitempty"`
	// authorized members list
	AuthorizedMembers []string `protobuf:"bytes,8,rep,name=authorized_members,json=authorizedMembers,proto3" json:"authorized_members,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetCaptainsTotalCount() uint64 {
	if m != nil {
		return m.CaptainsTotalCount
	}
	return 0
}

func (m *Params) GetMinimumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MinimumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetMaximumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MaximumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetCaptainsConstant() uint64 {
	if m != nil {
		return m.CaptainsConstant
	}
	return 0
}

func (m *Params) GetMaximumHoldingAmount() uint64 {
	if m != nil {
		return m.MaximumHoldingAmount
	}
	return 0
}

func (m *Params) GetCurrentSaleLevel() uint64 {
	if m != nil {
		return m.CurrentSaleLevel
	}
	return 0
}

func (m *Params) GetAuthorizedMembers() []string {
	if m != nil {
		return m.AuthorizedMembers
	}
	return nil
}

// Division defines the division a node belongs to.
type Division struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// level defines the level of the node.
	Level uint64 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	// initial_supply defines the initial supply of the node in the division.
	InitialSupply uint64 `protobuf:"varint,3,opt,name=initial_supply,json=initialSupply,proto3" json:"initial_supply,omitempty"`
	// sold_count defines the total count of the node in the division.
	SoldCount uint64 `protobuf:"varint,4,opt,name=sold_count,json=soldCount,proto3" json:"sold_count,omitempty"`
	// total_count defines the supply count of nodes in the division.
	TotalCount uint64 `protobuf:"varint,5,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// computing_power_lower_bound defines the low bound of computing power in the division.
	ComputingPowerLowerBound uint64 `protobuf:"varint,6,opt,name=computing_power_lower_bound,json=computingPowerLowerBound,proto3" json:"computing_power_lower_bound,omitempty"`
	// computing_power_upper_bound defines the upper bound of computing power in the division.
	ComputingPowerUpperBound uint64 `protobuf:"varint,7,opt,name=computing_power_upper_bound,json=computingPowerUpperBound,proto3" json:"computing_power_upper_bound,omitempty"`
}

func (m *Division) Reset()         { *m = Division{} }
func (m *Division) String() string { return proto.CompactTextString(m) }
func (*Division) ProtoMessage()    {}
func (*Division) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{1}
}
func (m *Division) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Division) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Division.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Division) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Division.Merge(m, src)
}
func (m *Division) XXX_Size() int {
	return m.Size()
}
func (m *Division) XXX_DiscardUnknown() {
	xxx_messageInfo_Division.DiscardUnknown(m)
}

var xxx_messageInfo_Division proto.InternalMessageInfo

func (m *Division) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Division) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Division) GetInitialSupply() uint64 {
	if m != nil {
		return m.InitialSupply
	}
	return 0
}

func (m *Division) GetSoldCount() uint64 {
	if m != nil {
		return m.SoldCount
	}
	return 0
}

func (m *Division) GetTotalCount() uint64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *Division) GetComputingPowerLowerBound() uint64 {
	if m != nil {
		return m.ComputingPowerLowerBound
	}
	return 0
}

func (m *Division) GetComputingPowerUpperBound() uint64 {
	if m != nil {
		return m.ComputingPowerUpperBound
	}
	return 0
}

// Node defines the node
type Node struct {
	Id             string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DivisionId     string `protobuf:"bytes,2,opt,name=division_id,json=divisionId,proto3" json:"division_id,omitempty"`
	Owner          string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	ComputingPower uint64 `protobuf:"varint,4,opt,name=computing_power,json=computingPower,proto3" json:"computing_power,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetDivisionId() string {
	if m != nil {
		return m.DivisionId
	}
	return ""
}

func (m *Node) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Node) GetComputingPower() uint64 {
	if m != nil {
		return m.ComputingPower
	}
	return 0
}

// EpochInfo defines the epoch information
type EpochBase struct {
	EmissionSum           github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=emission_sum,json=emissionSum,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"emission_sum"`
	HistoricalEmissionSum github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=historical_emission_sum,json=historicalEmissionSum,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"historical_emission_sum"`
	ComputingPowerSum     github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=computing_power_sum,json=computingPowerSum,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"computing_power_sum"`
	PledgeAmountSum       github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=pledge_amount_sum,json=pledgeAmountSum,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"pledge_amount_sum"`
}

func (m *EpochBase) Reset()         { *m = EpochBase{} }
func (m *EpochBase) String() string { return proto.CompactTextString(m) }
func (*EpochBase) ProtoMessage()    {}
func (*EpochBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{3}
}
func (m *EpochBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochBase.Merge(m, src)
}
func (m *EpochBase) XXX_Size() int {
	return m.Size()
}
func (m *EpochBase) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochBase.DiscardUnknown(m)
}

var xxx_messageInfo_EpochBase proto.InternalMessageInfo

// BatchBase defines the batch base
type BatchBase struct {
	Id    uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Count uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *BatchBase) Reset()         { *m = BatchBase{} }
func (m *BatchBase) String() string { return proto.CompactTextString(m) }
func (*BatchBase) ProtoMessage()    {}
func (*BatchBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{4}
}
func (m *BatchBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchBase.Merge(m, src)
}
func (m *BatchBase) XXX_Size() int {
	return m.Size()
}
func (m *BatchBase) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchBase.DiscardUnknown(m)
}

var xxx_messageInfo_BatchBase proto.InternalMessageInfo

func (m *BatchBase) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BatchBase) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// EpochState defines the epoch state
type EpochState struct {
	CurrEpoch uint64        `protobuf:"varint,1,opt,name=curr_epoch,json=currEpoch,proto3" json:"curr_epoch,omitempty"`
	IsEnd     bool          `protobuf:"varint,2,opt,name=is_end,json=isEnd,proto3" json:"is_end,omitempty"`
	Digest    *ReportDigest `protobuf:"bytes,3,opt,name=digest,proto3" json:"digest,omitempty"`
	Batches   []BatchBase   `protobuf:"bytes,4,rep,name=batches,proto3" json:"batches"`
	Current   EpochBase     `protobuf:"bytes,5,opt,name=current,proto3" json:"current"`
	Previous  EpochBase     `protobuf:"bytes,6,opt,name=previous,proto3" json:"previous"`
}

func (m *EpochState) Reset()         { *m = EpochState{} }
func (m *EpochState) String() string { return proto.CompactTextString(m) }
func (*EpochState) ProtoMessage()    {}
func (*EpochState) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{5}
}
func (m *EpochState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochState.Merge(m, src)
}
func (m *EpochState) XXX_Size() int {
	return m.Size()
}
func (m *EpochState) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochState.DiscardUnknown(m)
}

var xxx_messageInfo_EpochState proto.InternalMessageInfo

func (m *EpochState) GetCurrEpoch() uint64 {
	if m != nil {
		return m.CurrEpoch
	}
	return 0
}

func (m *EpochState) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func (m *EpochState) GetDigest() *ReportDigest {
	if m != nil {
		return m.Digest
	}
	return nil
}

func (m *EpochState) GetBatches() []BatchBase {
	if m != nil {
		return m.Batches
	}
	return nil
}

func (m *EpochState) GetCurrent() EpochBase {
	if m != nil {
		return m.Current
	}
	return EpochBase{}
}

func (m *EpochState) GetPrevious() EpochBase {
	if m != nil {
		return m.Previous
	}
	return EpochBase{}
}

type NodeExtraInfo struct {
	Id                          string                                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	LastClaimHistoricalEmission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=last_claim_historical_emission,json=lastClaimHistoricalEmission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"last_claim_historical_emission"`
	Epochs                      []NodeEpochInfo                        `protobuf:"bytes,3,rep,name=epochs,proto3" json:"epochs"`
}

func (m *NodeExtraInfo) Reset()         { *m = NodeExtraInfo{} }
func (m *NodeExtraInfo) String() string { return proto.CompactTextString(m) }
func (*NodeExtraInfo) ProtoMessage()    {}
func (*NodeExtraInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{6}
}
func (m *NodeExtraInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeExtraInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeExtraInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeExtraInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeExtraInfo.Merge(m, src)
}
func (m *NodeExtraInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeExtraInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeExtraInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeExtraInfo proto.InternalMessageInfo

func (m *NodeExtraInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeExtraInfo) GetEpochs() []NodeEpochInfo {
	if m != nil {
		return m.Epochs
	}
	return nil
}

// NodeEpochInfo defines the node info on epoch
type NodeEpochInfo struct {
	EpochId            uint64                                 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	HistoricalEmission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=historical_emission,json=historicalEmission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"historical_emission"`
	ComputingPower     github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=computing_power,json=computingPower,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"computing_power"`
}

func (m *NodeEpochInfo) Reset()         { *m = NodeEpochInfo{} }
func (m *NodeEpochInfo) String() string { return proto.CompactTextString(m) }
func (*NodeEpochInfo) ProtoMessage()    {}
func (*NodeEpochInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{7}
}
func (m *NodeEpochInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeEpochInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeEpochInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeEpochInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeEpochInfo.Merge(m, src)
}
func (m *NodeEpochInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeEpochInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeEpochInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeEpochInfo proto.InternalMessageInfo

func (m *NodeEpochInfo) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

// ClaimableComputingPower defines claimable reward of computing power to the owner.
type ClaimableComputingPower struct {
	Amount uint64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Owner  string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *ClaimableComputingPower) Reset()         { *m = ClaimableComputingPower{} }
func (m *ClaimableComputingPower) String() string { return proto.CompactTextString(m) }
func (*ClaimableComputingPower) ProtoMessage()    {}
func (*ClaimableComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{8}
}
func (m *ClaimableComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimableComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimableComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimableComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimableComputingPower.Merge(m, src)
}
func (m *ClaimableComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *ClaimableComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimableComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimableComputingPower proto.InternalMessageInfo

func (m *ClaimableComputingPower) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ClaimableComputingPower) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func init() {
	proto.RegisterType((*Params)(nil), "tabi.captains.v1.Params")
	proto.RegisterType((*Division)(nil), "tabi.captains.v1.Division")
	proto.RegisterType((*Node)(nil), "tabi.captains.v1.Node")
	proto.RegisterType((*EpochBase)(nil), "tabi.captains.v1.EpochBase")
	proto.RegisterType((*BatchBase)(nil), "tabi.captains.v1.BatchBase")
	proto.RegisterType((*EpochState)(nil), "tabi.captains.v1.EpochState")
	proto.RegisterType((*NodeExtraInfo)(nil), "tabi.captains.v1.NodeExtraInfo")
	proto.RegisterType((*NodeEpochInfo)(nil), "tabi.captains.v1.NodeEpochInfo")
	proto.RegisterType((*ClaimableComputingPower)(nil), "tabi.captains.v1.ClaimableComputingPower")
}

func init() { proto.RegisterFile("tabi/captains/v1/captains.proto", fileDescriptor_35d5085f64c624e4) }

var fileDescriptor_35d5085f64c624e4 = []byte{
	// 989 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0xb6, 0x3e, 0x2c, 0x8b, 0xa3, 0x37, 0x4e, 0xbc, 0x51, 0x62, 0x26, 0x46, 0x24, 0x43, 0xc0,
	0xdb, 0xba, 0x68, 0x2d, 0xd5, 0xe9, 0xc7, 0xa5, 0xf5, 0x21, 0x92, 0x05, 0xc4, 0x40, 0xda, 0x1a,
	0x54, 0x7b, 0xe9, 0x65, 0xb1, 0x22, 0xd7, 0xd2, 0xa2, 0x24, 0x97, 0xe0, 0x2e, 0x15, 0xa7, 0xa7,
	0xf6, 0x1f, 0xf4, 0xd2, 0x5f, 0xd2, 0x9c, 0xfa, 0x0b, 0x72, 0x0c, 0x72, 0x2a, 0x7a, 0x30, 0x0a,
	0xfb, 0x8f, 0x14, 0xfb, 0x41, 0xca, 0xb2, 0x74, 0x28, 0x50, 0xf5, 0x22, 0x71, 0xe7, 0x99, 0x67,
	0x67, 0x67, 0xe6, 0x99, 0x25, 0xa1, 0x2d, 0xc9, 0x98, 0xf5, 0x7c, 0x92, 0x48, 0xc2, 0x62, 0xd1,
	0x9b, 0x1d, 0x15, 0xcf, 0xdd, 0x24, 0xe5, 0x92, 0xa3, 0x7b, 0xca, 0xa1, 0x5b, 0x18, 0x67, 0x47,
	0x8f, 0x9b, 0x13, 0x3e, 0xe1, 0x1a, 0xec, 0xa9, 0x27, 0xe3, 0xf7, 0xf8, 0x91, 0xcf, 0x45, 0xc4,
	0x05, 0x36, 0x80, 0x59, 0x58, 0xe8, 0xc9, 0x52, 0x8c, 0x94, 0x26, 0x3c, 0x95, 0x06, 0xee, 0x5c,
	0x56, 0xa0, 0x76, 0x46, 0x52, 0x12, 0x09, 0xf4, 0x31, 0x34, 0x73, 0x37, 0x2c, 0xb9, 0x24, 0x21,
	0xf6, 0x79, 0x16, 0x4b, 0xb7, 0xb4, 0x5f, 0x3a, 0xa8, 0x7a, 0x28, 0xc7, 0xbe, 0x55, 0xd0, 0x40,
	0x21, 0xe8, 0x33, 0xd8, 0x8d, 0x58, 0xcc, 0xa2, 0x2c, 0xc2, 0x09, 0x7f, 0x49, 0x53, 0xcc, 0x63,
	0x9c, 0xd0, 0x94, 0xf1, 0xc0, 0x2d, 0x6b, 0x52, 0xd3, 0xc2, 0x67, 0x0a, 0xfd, 0x26, 0x3e, 0xd3,
	0x98, 0xa6, 0x91, 0x8b, 0x95, 0xb4, 0x8a, 0xa5, 0x19, 0x78, 0x91, 0xf6, 0x21, 0xec, 0x14, 0xe7,
	0xf3, 0x79, 0x2c, 0x24, 0x89, 0xa5, 0x5b, 0xd5, 0x84, 0x7b, 0x39, 0x30, 0xb0, 0x76, 0xf4, 0x29,
	0x3c, 0xcc, 0x63, 0x4c, 0x79, 0x18, 0xb0, 0x78, 0x82, 0x49, 0xa4, 0xd3, 0xd9, 0x5c, 0x08, 0xf1,
	0xdc, 0x80, 0xcf, 0x34, 0x86, 0x24, 0xec, 0x4e, 0x49, 0x38, 0x53, 0xde, 0x34, 0x25, 0xd8, 0xe7,
	0xf4, 0xfc, 0x9c, 0xf9, 0x8c, 0xc6, 0xd2, 0xad, 0xed, 0x97, 0x0e, 0x9c, 0xfe, 0x97, 0x6f, 0x2e,
	0xdb, 0x1b, 0x7f, 0x5e, 0xb6, 0xdf, 0x9b, 0x30, 0x39, 0xcd, 0xc6, 0x5d, 0x9f, 0x47, 0xb6, 0xdc,
	0xf6, 0xef, 0x50, 0x04, 0x3f, 0xf4, 0xe4, 0xab, 0x84, 0x8a, 0xee, 0x09, 0xf5, 0xdf, 0xbd, 0x3e,
	0x04, 0xdb, 0x8d, 0x13, 0xea, 0x7b, 0x0f, 0xec, 0xe6, 0xc3, 0x94, 0x0c, 0xe6, 0x5b, 0xa3, 0x8f,
	0x00, 0xf9, 0x59, 0x9a, 0xd2, 0x58, 0x62, 0x41, 0x42, 0x8a, 0x43, 0x3a, 0xa3, 0xa1, 0xbb, 0x65,
	0x33, 0x33, 0xc8, 0x88, 0x84, 0xf4, 0x85, 0xb2, 0xa3, 0x43, 0x40, 0x24, 0x93, 0x53, 0x9e, 0xb2,
	0x1f, 0x69, 0x80, 0x23, 0x1a, 0x8d, 0x69, 0x2a, 0xdc, 0xfa, 0x7e, 0xe5, 0xc0, 0xf1, 0x76, 0xe6,
	0xc8, 0x57, 0x06, 0xe8, 0xfc, 0x5a, 0x86, 0xfa, 0x09, 0x9b, 0x31, 0xc1, 0x78, 0x8c, 0xb6, 0xa1,
	0xcc, 0x02, 0xdd, 0x50, 0xc7, 0x2b, 0xb3, 0x00, 0x35, 0x61, 0xd3, 0x04, 0x33, 0xed, 0x32, 0x0b,
	0xf4, 0x7f, 0xd8, 0x66, 0x31, 0x93, 0x8c, 0x84, 0x58, 0x64, 0x49, 0x12, 0xbe, 0xb2, 0x6d, 0xb9,
	0x63, 0xad, 0x23, 0x6d, 0x44, 0x4f, 0x00, 0x04, 0x0f, 0x03, 0xab, 0x12, 0xd3, 0x08, 0x47, 0x59,
	0x8c, 0x38, 0xda, 0xd0, 0xb8, 0xa9, 0x22, 0x53, 0x76, 0x90, 0x73, 0xf5, 0x1c, 0xc3, 0x9e, 0xcf,
	0xa3, 0x24, 0x93, 0xaa, 0xdc, 0x46, 0x08, 0xa1, 0xfe, 0x1d, 0xf3, 0x2c, 0x0e, 0x74, 0xc1, 0xab,
	0x9e, 0x5b, 0xb8, 0x68, 0x31, 0xbc, 0x50, 0x3f, 0x7d, 0x85, 0xaf, 0xa2, 0x67, 0x49, 0x52, 0xd0,
	0xb7, 0x56, 0xd1, 0xbf, 0x53, 0x0e, 0x9a, 0xde, 0x99, 0x41, 0xf5, 0x6b, 0x1e, 0xd0, 0xa5, 0x92,
	0xb4, 0xa1, 0x11, 0xd8, 0x72, 0x61, 0x66, 0x74, 0xec, 0x78, 0x90, 0x9b, 0x4e, 0x75, 0xcd, 0xf8,
	0xcb, 0x98, 0xa6, 0xba, 0x28, 0x8e, 0x67, 0x16, 0xe8, 0x7d, 0xb8, 0x7b, 0xeb, 0x34, 0xb6, 0x22,
	0xdb, 0x8b, 0x27, 0xe8, 0xfc, 0x5e, 0x01, 0x67, 0x98, 0x70, 0x7f, 0xda, 0x27, 0x82, 0x22, 0x0c,
	0xff, 0xa3, 0x11, 0x13, 0x3a, 0x9a, 0xc8, 0x22, 0x73, 0x8e, 0x7f, 0xa9, 0xb2, 0x46, 0xbe, 0xe3,
	0x28, 0x8b, 0xb4, 0xa2, 0x99, 0x90, 0x3c, 0x65, 0x3e, 0x09, 0xf1, 0x42, 0xac, 0xf2, 0x5a, 0x14,
	0x5d, 0x6c, 0x3e, 0xbc, 0x11, 0x35, 0x84, 0xfb, 0xb7, 0x7b, 0xa3, 0x22, 0x56, 0xd6, 0x10, 0x71,
	0x67, 0xb1, 0x9e, 0x2a, 0xda, 0x14, 0x76, 0x92, 0x90, 0x06, 0x13, 0x6a, 0x47, 0x5c, 0xc7, 0xaa,
	0xae, 0x21, 0xd6, 0x5d, 0xb3, 0xad, 0xb9, 0x1c, 0x46, 0x59, 0xd4, 0x39, 0x02, 0xa7, 0x4f, 0xa4,
	0xed, 0xdd, 0x5c, 0x39, 0xd5, 0x7c, 0x98, 0x8c, 0xd4, 0xed, 0x30, 0xe9, 0x45, 0xe7, 0xb7, 0x32,
	0x80, 0xee, 0xf7, 0x48, 0x12, 0x49, 0xd5, 0xd0, 0xa8, 0x89, 0xc6, 0x54, 0x99, 0x2c, 0xd9, 0x51,
	0x16, 0xed, 0x83, 0x1e, 0x40, 0x8d, 0x09, 0x4c, 0x63, 0x23, 0xbc, 0xba, 0xb7, 0xc9, 0xc4, 0x30,
	0x0e, 0xd0, 0xe7, 0x50, 0x0b, 0xd8, 0x84, 0x0a, 0xa9, 0x4b, 0xd8, 0x78, 0xda, 0xea, 0xde, 0x7e,
	0x31, 0x74, 0x3d, 0x7d, 0xab, 0x9f, 0x68, 0x2f, 0xcf, 0x7a, 0xa3, 0x2f, 0x60, 0x6b, 0xac, 0xce,
	0x4b, 0x85, 0x5b, 0xdd, 0xaf, 0x1c, 0x34, 0x9e, 0xee, 0x2d, 0x13, 0x8b, 0x84, 0xfa, 0x55, 0x55,
	0x2c, 0x2f, 0x67, 0x28, 0xb2, 0xbd, 0x7c, 0xf4, 0xf0, 0xae, 0x24, 0x17, 0x4a, 0xce, 0xc9, 0x96,
	0x81, 0x8e, 0xa1, 0x9e, 0xa4, 0x74, 0xc6, 0x78, 0x26, 0xf4, 0x24, 0xff, 0x23, 0x76, 0x41, 0xe9,
	0x5c, 0x95, 0xe0, 0x8e, 0x1a, 0xcf, 0xe1, 0x85, 0x4c, 0xc9, 0x69, 0x7c, 0xce, 0x97, 0xe6, 0xf4,
	0xe7, 0x12, 0xb4, 0x42, 0x22, 0x24, 0xf6, 0x43, 0xc2, 0x22, 0xbc, 0x42, 0xe4, 0x6b, 0x11, 0xf8,
	0x9e, 0x8a, 0x31, 0x50, 0x21, 0x9e, 0x2f, 0x29, 0x1d, 0x1d, 0x43, 0x4d, 0xf7, 0x51, 0xb8, 0x15,
	0x5d, 0xdd, 0xf6, 0x72, 0x8a, 0x3a, 0x09, 0xe5, 0xa3, 0x92, 0xb0, 0x69, 0x5a, 0x52, 0xe7, 0xa7,
	0xb2, 0x4d, 0x32, 0xc7, 0xd1, 0x23, 0xa8, 0x6b, 0x0c, 0x17, 0xc2, 0xda, 0xd2, 0xeb, 0xd3, 0x00,
	0x45, 0x70, 0xff, 0xbf, 0xca, 0x11, 0x2d, 0x0f, 0x31, 0xa2, 0xcb, 0xf7, 0xd9, 0x3a, 0xa6, 0xf7,
	0xf6, 0x6d, 0x48, 0x60, 0x57, 0x17, 0x97, 0x8c, 0x43, 0x3a, 0x58, 0x80, 0xd0, 0x43, 0xa8, 0xd9,
	0x37, 0xb6, 0xa9, 0x84, 0x5d, 0xa1, 0x6e, 0x7e, 0xff, 0x9a, 0xd4, 0xdd, 0x77, 0xaf, 0x0f, 0x9b,
	0x36, 0xc2, 0xb3, 0x20, 0x48, 0xa9, 0x10, 0x23, 0x99, 0xb2, 0x78, 0x62, 0x6f, 0xe6, 0xfe, 0xe0,
	0xcd, 0x55, 0xab, 0xf4, 0xf6, 0xaa, 0x55, 0xfa, 0xeb, 0xaa, 0x55, 0xfa, 0xe5, 0xba, 0xb5, 0xf1,
	0xf6, 0xba, 0xb5, 0xf1, 0xc7, 0x75, 0x6b, 0xe3, 0xfb, 0x0f, 0x6e, 0xa4, 0xa0, 0x1a, 0x17, 0x92,
	0xb1, 0xd0, 0x0f, 0xbd, 0x8b, 0xf9, 0x07, 0x93, 0xce, 0x64, 0x5c, 0xd3, 0x5f, 0x4b, 0x9f, 0xfc,
	0x1d, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x58, 0x2c, 0x93, 0xb2, 0x09, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorizedMembers) > 0 {
		for iNdEx := len(m.AuthorizedMembers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthorizedMembers[iNdEx])
			copy(dAtA[i:], m.AuthorizedMembers[iNdEx])
			i = encodeVarintCaptains(dAtA, i, uint64(len(m.AuthorizedMembers[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CurrentSaleLevel != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CurrentSaleLevel))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.HalvingEraCoefficient.Size()
		i -= size
		if _, err := m.HalvingEraCoefficient.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.MaximumHoldingAmount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MaximumHoldingAmount))
		i--
		dAtA[i] = 0x28
	}
	if m.CaptainsConstant != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CaptainsConstant))
		i--
		dAtA[i] = 0x20
	}
	if m.MaximumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MaximumPowerOnPeriod))
		i--
		dAtA[i] = 0x18
	}
	if m.MinimumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MinimumPowerOnPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.CaptainsTotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CaptainsTotalCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Division) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Division) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Division) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPowerUpperBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerUpperBound))
		i--
		dAtA[i] = 0x38
	}
	if m.ComputingPowerLowerBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerLowerBound))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x28
	}
	if m.SoldCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.SoldCount))
		i--
		dAtA[i] = 0x20
	}
	if m.InitialSupply != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.InitialSupply))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPower != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DivisionId) > 0 {
		i -= len(m.DivisionId)
		copy(dAtA[i:], m.DivisionId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.DivisionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EpochBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.PledgeAmountSum.Size()
		i -= size
		if _, err := m.PledgeAmountSum.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.ComputingPowerSum.Size()
		i -= size
		if _, err := m.ComputingPowerSum.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.HistoricalEmissionSum.Size()
		i -= size
		if _, err := m.HistoricalEmissionSum.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.EmissionSum.Size()
		i -= size
		if _, err := m.EmissionSum.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *BatchBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Previous.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Current.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Batches) > 0 {
		for iNdEx := len(m.Batches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Batches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCaptains(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Digest != nil {
		{
			size, err := m.Digest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCaptains(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.IsEnd {
		i--
		if m.IsEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CurrEpoch != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CurrEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeExtraInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeExtraInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeExtraInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Epochs) > 0 {
		for iNdEx := len(m.Epochs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Epochs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCaptains(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	{
		size := m.LastClaimHistoricalEmission.Size()
		i -= size
		if _, err := m.LastClaimHistoricalEmission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeEpochInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeEpochInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeEpochInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.ComputingPower.Size()
		i -= size
		if _, err := m.ComputingPower.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.HistoricalEmission.Size()
		i -= size
		if _, err := m.HistoricalEmission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClaimableComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimableComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimableComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCaptains(dAtA []byte, offset int, v uint64) int {
	offset -= sovCaptains(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptainsTotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.CaptainsTotalCount))
	}
	if m.MinimumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MinimumPowerOnPeriod))
	}
	if m.MaximumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MaximumPowerOnPeriod))
	}
	if m.CaptainsConstant != 0 {
		n += 1 + sovCaptains(uint64(m.CaptainsConstant))
	}
	if m.MaximumHoldingAmount != 0 {
		n += 1 + sovCaptains(uint64(m.MaximumHoldingAmount))
	}
	l = m.HalvingEraCoefficient.Size()
	n += 1 + l + sovCaptains(uint64(l))
	if m.CurrentSaleLevel != 0 {
		n += 1 + sovCaptains(uint64(m.CurrentSaleLevel))
	}
	if len(m.AuthorizedMembers) > 0 {
		for _, s := range m.AuthorizedMembers {
			l = len(s)
			n += 1 + l + sovCaptains(uint64(l))
		}
	}
	return n
}

func (m *Division) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovCaptains(uint64(m.Level))
	}
	if m.InitialSupply != 0 {
		n += 1 + sovCaptains(uint64(m.InitialSupply))
	}
	if m.SoldCount != 0 {
		n += 1 + sovCaptains(uint64(m.SoldCount))
	}
	if m.TotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.TotalCount))
	}
	if m.ComputingPowerLowerBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerLowerBound))
	}
	if m.ComputingPowerUpperBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerUpperBound))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.DivisionId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.ComputingPower != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPower))
	}
	return n
}

func (m *EpochBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.EmissionSum.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.HistoricalEmissionSum.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.ComputingPowerSum.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.PledgeAmountSum.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *BatchBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCaptains(uint64(m.Id))
	}
	if m.Count != 0 {
		n += 1 + sovCaptains(uint64(m.Count))
	}
	return n
}

func (m *EpochState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrEpoch != 0 {
		n += 1 + sovCaptains(uint64(m.CurrEpoch))
	}
	if m.IsEnd {
		n += 2
	}
	if m.Digest != nil {
		l = m.Digest.Size()
		n += 1 + l + sovCaptains(uint64(l))
	}
	if len(m.Batches) > 0 {
		for _, e := range m.Batches {
			l = e.Size()
			n += 1 + l + sovCaptains(uint64(l))
		}
	}
	l = m.Current.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.Previous.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *NodeExtraInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = m.LastClaimHistoricalEmission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	if len(m.Epochs) > 0 {
		for _, e := range m.Epochs {
			l = e.Size()
			n += 1 + l + sovCaptains(uint64(l))
		}
	}
	return n
}

func (m *NodeEpochInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.HistoricalEmission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.ComputingPower.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *ClaimableComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovCaptains(uint64(m.Amount))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	return n
}

func sovCaptains(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCaptains(x uint64) (n int) {
	return sovCaptains(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsTotalCount", wireType)
			}
			m.CaptainsTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainsTotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumPowerOnPeriod", wireType)
			}
			m.MinimumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPowerOnPeriod", wireType)
			}
			m.MaximumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsConstant", wireType)
			}
			m.CaptainsConstant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainsConstant |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumHoldingAmount", wireType)
			}
			m.MaximumHoldingAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumHoldingAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalvingEraCoefficient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HalvingEraCoefficient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSaleLevel", wireType)
			}
			m.CurrentSaleLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSaleLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizedMembers = append(m.AuthorizedMembers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Division) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Division: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Division: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSupply", wireType)
			}
			m.InitialSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldCount", wireType)
			}
			m.SoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerLowerBound", wireType)
			}
			m.ComputingPowerLowerBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerLowerBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerUpperBound", wireType)
			}
			m.ComputingPowerUpperBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerUpperBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DivisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPower", wireType)
			}
			m.ComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmissionSum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EmissionSum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalEmissionSum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HistoricalEmissionSum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerSum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ComputingPowerSum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PledgeAmountSum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PledgeAmountSum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrEpoch", wireType)
			}
			m.CurrEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEnd = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Digest == nil {
				m.Digest = &ReportDigest{}
			}
			if err := m.Digest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batches = append(m.Batches, BatchBase{})
			if err := m.Batches[len(m.Batches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Current.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Previous", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Previous.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeExtraInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeExtraInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeExtraInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastClaimHistoricalEmission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LastClaimHistoricalEmission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epochs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Epochs = append(m.Epochs, NodeEpochInfo{})
			if err := m.Epochs[len(m.Epochs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeEpochInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeEpochInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeEpochInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalEmission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HistoricalEmission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ComputingPower.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimableComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimableComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimableComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCaptains(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCaptains
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCaptains
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCaptains
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCaptains        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCaptains          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCaptains = fmt.Errorf("proto: unexpected end of group")
)
