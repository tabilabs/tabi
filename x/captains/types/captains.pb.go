// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tabi/captains/v1/captains.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines captains module's parameters
type Params struct {
	// captains_total_count defines the total count of the captains
	CaptainsTotalCount uint64 `protobuf:"varint,1,opt,name=captains_total_count,json=captainsTotalCount,proto3" json:"captains_total_count,omitempty"`
	// minimum_power_on_period defines the minimum period for a captain to be powered on
	MinimumPowerOnPeriod uint64 `protobuf:"varint,2,opt,name=minimum_power_on_period,json=minimumPowerOnPeriod,proto3" json:"minimum_power_on_period,omitempty"`
	// maximum_power_on_period defines the maximum period for a captain to be powered on
	MaximumPowerOnPeriod uint64 `protobuf:"varint,3,opt,name=maximum_power_on_period,json=maximumPowerOnPeriod,proto3" json:"maximum_power_on_period,omitempty"`
	// captains_constant is a fixed constant for reward calculation
	CaptainsConstant github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=captains_constant,json=captainsConstant,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"captains_constant"`
	// halving_era defines the halving era coefficient
	HalvingEraCoefficient github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,5,opt,name=halving_era_coefficient,json=halvingEraCoefficient,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"halving_era_coefficient"`
	// tech_progress_coefficient defines the tech progress coefficient cardinality.
	TechProgressCoefficientCardinality github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=tech_progress_coefficient_cardinality,json=techProgressCoefficientCardinality,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"tech_progress_coefficient_cardinality"`
	// current_sale_level defines the current level for sale.
	CurrentSaleLevel uint64 `protobuf:"varint,7,opt,name=current_sale_level,json=currentSaleLevel,proto3" json:"current_sale_level,omitempty"`
	// authorized members list
	AuthorizedMembers []string `protobuf:"bytes,8,rep,name=authorized_members,json=authorizedMembers,proto3" json:"authorized_members,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetCaptainsTotalCount() uint64 {
	if m != nil {
		return m.CaptainsTotalCount
	}
	return 0
}

func (m *Params) GetMinimumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MinimumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetMaximumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MaximumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetCurrentSaleLevel() uint64 {
	if m != nil {
		return m.CurrentSaleLevel
	}
	return 0
}

func (m *Params) GetAuthorizedMembers() []string {
	if m != nil {
		return m.AuthorizedMembers
	}
	return nil
}

// Division defines the division a node belongs to.
type Division struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// level defines the level of the node.
	Level uint64 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	// initial_supply defines the initial supply of the node in the division.
	InitialSupply uint64 `protobuf:"varint,3,opt,name=initial_supply,json=initialSupply,proto3" json:"initial_supply,omitempty"`
	// sold_count defines the total count of the node in the division.
	SoldCount uint64 `protobuf:"varint,4,opt,name=sold_count,json=soldCount,proto3" json:"sold_count,omitempty"`
	// total_count defines the supply count of nodes in the division.
	TotalCount uint64 `protobuf:"varint,5,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// computing_power_lower_bound defines the low bound of computing power in the division.
	ComputingPowerLowerBound uint64 `protobuf:"varint,6,opt,name=computing_power_lower_bound,json=computingPowerLowerBound,proto3" json:"computing_power_lower_bound,omitempty"`
	// computing_power_upper_bound defines the upper bound of computing power in the division.
	ComputingPowerUpperBound uint64 `protobuf:"varint,7,opt,name=computing_power_upper_bound,json=computingPowerUpperBound,proto3" json:"computing_power_upper_bound,omitempty"`
}

func (m *Division) Reset()         { *m = Division{} }
func (m *Division) String() string { return proto.CompactTextString(m) }
func (*Division) ProtoMessage()    {}
func (*Division) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{1}
}
func (m *Division) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Division) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Division.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Division) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Division.Merge(m, src)
}
func (m *Division) XXX_Size() int {
	return m.Size()
}
func (m *Division) XXX_DiscardUnknown() {
	xxx_messageInfo_Division.DiscardUnknown(m)
}

var xxx_messageInfo_Division proto.InternalMessageInfo

func (m *Division) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Division) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Division) GetInitialSupply() uint64 {
	if m != nil {
		return m.InitialSupply
	}
	return 0
}

func (m *Division) GetSoldCount() uint64 {
	if m != nil {
		return m.SoldCount
	}
	return 0
}

func (m *Division) GetTotalCount() uint64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *Division) GetComputingPowerLowerBound() uint64 {
	if m != nil {
		return m.ComputingPowerLowerBound
	}
	return 0
}

func (m *Division) GetComputingPowerUpperBound() uint64 {
	if m != nil {
		return m.ComputingPowerUpperBound
	}
	return 0
}

// Node defines the node
type Node struct {
	Id             string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DivisionId     string `protobuf:"bytes,2,opt,name=division_id,json=divisionId,proto3" json:"division_id,omitempty"`
	Owner          string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	ComputingPower uint64 `protobuf:"varint,4,opt,name=computing_power,json=computingPower,proto3" json:"computing_power,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetDivisionId() string {
	if m != nil {
		return m.DivisionId
	}
	return ""
}

func (m *Node) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Node) GetComputingPower() uint64 {
	if m != nil {
		return m.ComputingPower
	}
	return 0
}

// EpochState defines the state of the epoch
type BaseState struct {
	// id of the epoch
	EpochId uint64 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// whether the epoch is ended
	IsEpochEnd bool `protobuf:"varint,2,opt,name=is_epoch_end,json=isEpochEnd,proto3" json:"is_epoch_end,omitempty"`
	// the next node sequence
	NextNodeSequence uint64 `protobuf:"varint,3,opt,name=next_node_sequence,json=nextNodeSequence,proto3" json:"next_node_sequence,omitempty"`
	// global claimed emission
	GlobalClaimedEmission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,4,opt,name=global_claimed_emission,json=globalClaimedEmission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"global_claimed_emission"`
	// the digest of the report
	ReportDigest *ReportDigest `protobuf:"bytes,5,opt,name=report_digest,json=reportDigest,proto3" json:"report_digest,omitempty"`
}

func (m *BaseState) Reset()         { *m = BaseState{} }
func (m *BaseState) String() string { return proto.CompactTextString(m) }
func (*BaseState) ProtoMessage()    {}
func (*BaseState) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{3}
}
func (m *BaseState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BaseState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BaseState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BaseState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BaseState.Merge(m, src)
}
func (m *BaseState) XXX_Size() int {
	return m.Size()
}
func (m *BaseState) XXX_DiscardUnknown() {
	xxx_messageInfo_BaseState.DiscardUnknown(m)
}

var xxx_messageInfo_BaseState proto.InternalMessageInfo

func (m *BaseState) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *BaseState) GetIsEpochEnd() bool {
	if m != nil {
		return m.IsEpochEnd
	}
	return false
}

func (m *BaseState) GetNextNodeSequence() uint64 {
	if m != nil {
		return m.NextNodeSequence
	}
	return 0
}

func (m *BaseState) GetReportDigest() *ReportDigest {
	if m != nil {
		return m.ReportDigest
	}
	return nil
}

type EpochEmission struct {
	EpochId  uint64                                 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Emission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=emission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"emission"`
}

func (m *EpochEmission) Reset()         { *m = EpochEmission{} }
func (m *EpochEmission) String() string { return proto.CompactTextString(m) }
func (*EpochEmission) ProtoMessage()    {}
func (*EpochEmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{4}
}
func (m *EpochEmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochEmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochEmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochEmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochEmission.Merge(m, src)
}
func (m *EpochEmission) XXX_Size() int {
	return m.Size()
}
func (m *EpochEmission) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochEmission.DiscardUnknown(m)
}

var xxx_messageInfo_EpochEmission proto.InternalMessageInfo

func (m *EpochEmission) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

type NodeClaimedEmission struct {
	NodeId   string                                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Emission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=emission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"emission"`
}

func (m *NodeClaimedEmission) Reset()         { *m = NodeClaimedEmission{} }
func (m *NodeClaimedEmission) String() string { return proto.CompactTextString(m) }
func (*NodeClaimedEmission) ProtoMessage()    {}
func (*NodeClaimedEmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{5}
}
func (m *NodeClaimedEmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeClaimedEmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeClaimedEmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeClaimedEmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeClaimedEmission.Merge(m, src)
}
func (m *NodeClaimedEmission) XXX_Size() int {
	return m.Size()
}
func (m *NodeClaimedEmission) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeClaimedEmission.DiscardUnknown(m)
}

var xxx_messageInfo_NodeClaimedEmission proto.InternalMessageInfo

func (m *NodeClaimedEmission) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

type ClaimableComputingPower struct {
	Amount uint64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Owner  string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *ClaimableComputingPower) Reset()         { *m = ClaimableComputingPower{} }
func (m *ClaimableComputingPower) String() string { return proto.CompactTextString(m) }
func (*ClaimableComputingPower) ProtoMessage()    {}
func (*ClaimableComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{6}
}
func (m *ClaimableComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimableComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimableComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimableComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimableComputingPower.Merge(m, src)
}
func (m *ClaimableComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *ClaimableComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimableComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimableComputingPower proto.InternalMessageInfo

func (m *ClaimableComputingPower) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ClaimableComputingPower) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

type NodeCumulativeEmission struct {
	NodeId   string                                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	EpochId  uint64                                 `protobuf:"varint,2,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Emission github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=emission,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"emission"`
}

func (m *NodeCumulativeEmission) Reset()         { *m = NodeCumulativeEmission{} }
func (m *NodeCumulativeEmission) String() string { return proto.CompactTextString(m) }
func (*NodeCumulativeEmission) ProtoMessage()    {}
func (*NodeCumulativeEmission) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{7}
}
func (m *NodeCumulativeEmission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCumulativeEmission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCumulativeEmission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCumulativeEmission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCumulativeEmission.Merge(m, src)
}
func (m *NodeCumulativeEmission) XXX_Size() int {
	return m.Size()
}
func (m *NodeCumulativeEmission) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCumulativeEmission.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCumulativeEmission proto.InternalMessageInfo

func (m *NodeCumulativeEmission) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *NodeCumulativeEmission) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

type GlobalComputingPower struct {
	EpochId uint64                                 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Amount  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *GlobalComputingPower) Reset()         { *m = GlobalComputingPower{} }
func (m *GlobalComputingPower) String() string { return proto.CompactTextString(m) }
func (*GlobalComputingPower) ProtoMessage()    {}
func (*GlobalComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{8}
}
func (m *GlobalComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalComputingPower.Merge(m, src)
}
func (m *GlobalComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *GlobalComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalComputingPower proto.InternalMessageInfo

func (m *GlobalComputingPower) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

type NodesComputingPower struct {
	NodeId  string                                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	EpochId uint64                                 `protobuf:"varint,2,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Amount  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *NodesComputingPower) Reset()         { *m = NodesComputingPower{} }
func (m *NodesComputingPower) String() string { return proto.CompactTextString(m) }
func (*NodesComputingPower) ProtoMessage()    {}
func (*NodesComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{9}
}
func (m *NodesComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodesComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodesComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodesComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodesComputingPower.Merge(m, src)
}
func (m *NodesComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *NodesComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_NodesComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_NodesComputingPower proto.InternalMessageInfo

func (m *NodesComputingPower) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *NodesComputingPower) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

type GlobalPledge struct {
	EpochId uint64                                 `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Amount  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *GlobalPledge) Reset()         { *m = GlobalPledge{} }
func (m *GlobalPledge) String() string { return proto.CompactTextString(m) }
func (*GlobalPledge) ProtoMessage()    {}
func (*GlobalPledge) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{10}
}
func (m *GlobalPledge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalPledge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalPledge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalPledge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalPledge.Merge(m, src)
}
func (m *GlobalPledge) XXX_Size() int {
	return m.Size()
}
func (m *GlobalPledge) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalPledge.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalPledge proto.InternalMessageInfo

func (m *GlobalPledge) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

type OwnerPledge struct {
	Owner   string                                 `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	EpochId uint64                                 `protobuf:"varint,2,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Amount  github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=amount,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"amount"`
}

func (m *OwnerPledge) Reset()         { *m = OwnerPledge{} }
func (m *OwnerPledge) String() string { return proto.CompactTextString(m) }
func (*OwnerPledge) ProtoMessage()    {}
func (*OwnerPledge) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{11}
}
func (m *OwnerPledge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerPledge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerPledge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerPledge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerPledge.Merge(m, src)
}
func (m *OwnerPledge) XXX_Size() int {
	return m.Size()
}
func (m *OwnerPledge) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerPledge.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerPledge proto.InternalMessageInfo

func (m *OwnerPledge) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *OwnerPledge) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "tabi.captains.v1.Params")
	proto.RegisterType((*Division)(nil), "tabi.captains.v1.Division")
	proto.RegisterType((*Node)(nil), "tabi.captains.v1.Node")
	proto.RegisterType((*BaseState)(nil), "tabi.captains.v1.BaseState")
	proto.RegisterType((*EpochEmission)(nil), "tabi.captains.v1.EpochEmission")
	proto.RegisterType((*NodeClaimedEmission)(nil), "tabi.captains.v1.NodeClaimedEmission")
	proto.RegisterType((*ClaimableComputingPower)(nil), "tabi.captains.v1.ClaimableComputingPower")
	proto.RegisterType((*NodeCumulativeEmission)(nil), "tabi.captains.v1.NodeCumulativeEmission")
	proto.RegisterType((*GlobalComputingPower)(nil), "tabi.captains.v1.GlobalComputingPower")
	proto.RegisterType((*NodesComputingPower)(nil), "tabi.captains.v1.NodesComputingPower")
	proto.RegisterType((*GlobalPledge)(nil), "tabi.captains.v1.GlobalPledge")
	proto.RegisterType((*OwnerPledge)(nil), "tabi.captains.v1.OwnerPledge")
}

func init() { proto.RegisterFile("tabi/captains/v1/captains.proto", fileDescriptor_35d5085f64c624e4) }

var fileDescriptor_35d5085f64c624e4 = []byte{
	// 944 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x56, 0x4d, 0x6f, 0x1b, 0x45,
	0x18, 0xce, 0x3a, 0x4e, 0x62, 0xbf, 0xf9, 0x20, 0x1d, 0xdc, 0xc6, 0x2d, 0xaa, 0x1d, 0x59, 0x2a,
	0x04, 0x89, 0xd8, 0x14, 0xc4, 0x0d, 0x0e, 0xc4, 0x89, 0x50, 0xa5, 0x42, 0xad, 0x75, 0x91, 0x10,
	0x97, 0xd1, 0x78, 0x67, 0xba, 0x1e, 0xb1, 0x3b, 0xb3, 0xec, 0xcc, 0xba, 0x09, 0x17, 0x2e, 0x48,
	0x70, 0x83, 0x03, 0x9c, 0xb9, 0x71, 0x47, 0xea, 0x8f, 0xe8, 0xb1, 0xea, 0x09, 0x71, 0xa8, 0x50,
	0xf2, 0x27, 0x38, 0xa2, 0xf9, 0xf0, 0xda, 0x49, 0x43, 0x91, 0x90, 0xdb, 0x8b, 0xb3, 0xf3, 0x3e,
	0xef, 0xe7, 0xf3, 0x3e, 0x3b, 0x59, 0x68, 0x6b, 0x32, 0xe2, 0xbd, 0x88, 0x64, 0x9a, 0x70, 0xa1,
	0x7a, 0x93, 0xdb, 0xe5, 0x73, 0x37, 0xcb, 0xa5, 0x96, 0x68, 0xdb, 0x38, 0x74, 0x4b, 0xe3, 0xe4,
	0xf6, 0x8d, 0x46, 0x2c, 0x63, 0x69, 0xc1, 0x9e, 0x79, 0x72, 0x7e, 0x37, 0xae, 0x47, 0x52, 0xa5,
	0x52, 0x61, 0x07, 0xb8, 0x83, 0x87, 0x6e, 0x3e, 0x57, 0x23, 0x67, 0x99, 0xcc, 0xb5, 0x83, 0x3b,
	0x7f, 0x57, 0x61, 0x75, 0x40, 0x72, 0x92, 0x2a, 0xf4, 0x2e, 0x34, 0xa6, 0x6e, 0x58, 0x4b, 0x4d,
	0x12, 0x1c, 0xc9, 0x42, 0xe8, 0x66, 0xb0, 0x1b, 0xec, 0x55, 0x43, 0x34, 0xc5, 0xee, 0x1b, 0xa8,
	0x6f, 0x10, 0xf4, 0x01, 0xec, 0xa4, 0x5c, 0xf0, 0xb4, 0x48, 0x71, 0x26, 0x1f, 0xb2, 0x1c, 0x4b,
	0x81, 0x33, 0x96, 0x73, 0x49, 0x9b, 0x15, 0x1b, 0xd4, 0xf0, 0xf0, 0xc0, 0xa0, 0xf7, 0xc4, 0xc0,
	0x62, 0x36, 0x8c, 0x1c, 0x5f, 0x1a, 0xb6, 0xec, 0xc3, 0x1c, 0x7c, 0x3e, 0x8c, 0xc3, 0x95, 0xb2,
	0xbf, 0x48, 0x0a, 0xa5, 0x89, 0xd0, 0xcd, 0xea, 0x6e, 0xb0, 0x57, 0x3f, 0xf8, 0xf0, 0xf1, 0xb3,
	0xf6, 0xd2, 0x9f, 0xcf, 0xda, 0x6f, 0xc6, 0x5c, 0x8f, 0x8b, 0x51, 0x37, 0x92, 0xa9, 0x67, 0xc1,
	0xff, 0xd9, 0x57, 0xf4, 0xab, 0x9e, 0x3e, 0xc9, 0x98, 0xea, 0x1e, 0xb2, 0xe8, 0xe9, 0xa3, 0x7d,
	0xf0, 0x24, 0x1d, 0xb2, 0x28, 0xdc, 0x9e, 0xa6, 0xed, 0xfb, 0xac, 0x48, 0xc3, 0xce, 0x98, 0x24,
	0x13, 0x2e, 0x62, 0xcc, 0x72, 0x82, 0x23, 0xc9, 0x1e, 0x3c, 0xe0, 0x11, 0x67, 0x42, 0x37, 0x57,
	0x16, 0x50, 0xf0, 0xaa, 0x4f, 0x7e, 0x94, 0x93, 0xfe, 0x2c, 0x35, 0xfa, 0x31, 0x80, 0x5b, 0x9a,
	0x45, 0x63, 0xb3, 0xc6, 0x38, 0x67, 0x4a, 0xcd, 0x17, 0xc6, 0x11, 0xc9, 0x29, 0x17, 0x24, 0xe1,
	0xfa, 0xa4, 0xb9, 0xba, 0x80, 0x26, 0x3a, 0xa6, 0xd4, 0xc0, 0x57, 0x9a, 0x6b, 0xa3, 0x3f, 0xab,
	0x83, 0xde, 0x01, 0x14, 0x15, 0x79, 0x6e, 0xca, 0x2b, 0x92, 0x30, 0x9c, 0xb0, 0x09, 0x4b, 0x9a,
	0x6b, 0x76, 0x49, 0xdb, 0x1e, 0x19, 0x92, 0x84, 0xdd, 0x35, 0x76, 0xb4, 0x0f, 0x88, 0x14, 0x7a,
	0x2c, 0x73, 0xfe, 0x0d, 0xa3, 0x38, 0x65, 0xe9, 0x88, 0xe5, 0xaa, 0x59, 0xdb, 0x5d, 0xde, 0xab,
	0x87, 0x57, 0x66, 0xc8, 0xa7, 0x0e, 0xe8, 0xfc, 0x52, 0x81, 0xda, 0x21, 0x9f, 0x70, 0xc5, 0xa5,
	0x40, 0x5b, 0x50, 0xe1, 0xd4, 0x4a, 0xad, 0x1e, 0x56, 0x38, 0x45, 0x0d, 0x58, 0x71, 0xc5, 0x9c,
	0x90, 0xdc, 0x01, 0xdd, 0x82, 0x2d, 0x2e, 0xb8, 0xe6, 0x24, 0xc1, 0xaa, 0xc8, 0xb2, 0xe4, 0xc4,
	0x0b, 0x66, 0xd3, 0x5b, 0x87, 0xd6, 0x88, 0x6e, 0x02, 0x28, 0x99, 0x50, 0xaf, 0xdf, 0xaa, 0x75,
	0xa9, 0x1b, 0x8b, 0x93, 0x6d, 0x1b, 0xd6, 0xe7, 0xf5, 0xbd, 0x62, 0x71, 0xd0, 0x33, 0x5d, 0x7f,
	0x04, 0x6f, 0x44, 0x32, 0xcd, 0x0a, 0x6d, 0x04, 0xe0, 0x24, 0x9a, 0xd8, 0xdf, 0x91, 0x2c, 0x04,
	0xb5, 0xec, 0x57, 0xc3, 0x66, 0xe9, 0x62, 0x65, 0x7a, 0xd7, 0xfc, 0x1c, 0x18, 0xfc, 0xb2, 0xf0,
	0x22, 0xcb, 0xca, 0xf0, 0xb5, 0xcb, 0xc2, 0x3f, 0x37, 0x0e, 0x36, 0xbc, 0x33, 0x81, 0xea, 0x67,
	0x92, 0xb2, 0xe7, 0x28, 0x69, 0xc3, 0x3a, 0xf5, 0x74, 0x61, 0xee, 0xde, 0xb0, 0x7a, 0x08, 0x53,
	0xd3, 0x1d, 0xcb, 0x99, 0x7c, 0x28, 0x58, 0x6e, 0x49, 0xa9, 0x87, 0xee, 0x80, 0xde, 0x82, 0xd7,
	0x2e, 0x74, 0xe3, 0x19, 0xd9, 0x3a, 0xdf, 0x41, 0xe7, 0xf7, 0x0a, 0xd4, 0x0f, 0x88, 0x62, 0x43,
	0x4d, 0x34, 0x43, 0xd7, 0xa1, 0xc6, 0x32, 0x19, 0x8d, 0xb1, 0xef, 0xa1, 0x1a, 0xae, 0xd9, 0xf3,
	0x1d, 0x8a, 0x76, 0x61, 0x83, 0x2b, 0xec, 0x50, 0x26, 0x5c, 0x27, 0xb5, 0x10, 0xb8, 0x3a, 0x32,
	0xa6, 0x23, 0x41, 0x8d, 0x6e, 0x04, 0x3b, 0xd6, 0x58, 0x48, 0xca, 0xb0, 0x62, 0x5f, 0x17, 0x4c,
	0x44, 0xcc, 0xef, 0x6a, 0xdb, 0x20, 0x66, 0xc0, 0xa1, 0xb7, 0x9b, 0xb7, 0x2d, 0x4e, 0xe4, 0xc8,
	0x2c, 0x24, 0x21, 0x3c, 0x65, 0x14, 0xb3, 0x94, 0x2b, 0x33, 0xd4, 0x42, 0x5e, 0xef, 0xab, 0x2e,
	0x79, 0xdf, 0xe5, 0x3e, 0xf2, 0xa9, 0x51, 0x1f, 0x36, 0xdd, 0x4d, 0x88, 0x29, 0x8f, 0x99, 0x72,
	0x3a, 0x58, 0x7f, 0xaf, 0xd5, 0xbd, 0x78, 0xe7, 0x76, 0x43, 0xeb, 0x76, 0x68, 0xbd, 0xc2, 0x8d,
	0x7c, 0xee, 0xd4, 0xf9, 0x2e, 0x80, 0x4d, 0x37, 0xf5, 0x34, 0xed, 0x0b, 0x78, 0xfb, 0x02, 0x6a,
	0xe5, 0x60, 0x95, 0x05, 0x0c, 0x56, 0x66, 0xeb, 0xfc, 0x10, 0xc0, 0xeb, 0x86, 0xd2, 0x8b, 0x33,
	0xee, 0xc0, 0x9a, 0x5d, 0x41, 0xa9, 0xa3, 0x55, 0x73, 0x7c, 0xa9, 0xad, 0x10, 0xd8, 0xb1, 0x5d,
	0x90, 0x51, 0xc2, 0xfa, 0xe7, 0x04, 0x86, 0xae, 0xc1, 0x2a, 0x49, 0xe7, 0xfe, 0xa5, 0xf8, 0x13,
	0xea, 0x4e, 0x75, 0xeb, 0x3a, 0x69, 0x3e, 0x7d, 0xb4, 0xdf, 0xf0, 0xb9, 0x3f, 0xa6, 0xd4, 0x5c,
	0x4f, 0x43, 0x9d, 0x73, 0x11, 0x7b, 0x45, 0x77, 0x7e, 0x0b, 0xe0, 0x9a, 0x9d, 0xb6, 0x48, 0x8b,
	0x84, 0x68, 0x3e, 0x61, 0xff, 0x3d, 0xf0, 0xfc, 0x5a, 0x2a, 0xff, 0xbe, 0x96, 0xe5, 0x85, 0x72,
	0xf1, 0x7d, 0x00, 0x8d, 0x4f, 0x9c, 0xf8, 0xce, 0x33, 0xf1, 0x02, 0x91, 0xdc, 0x2f, 0x49, 0x5a,
	0xc4, 0x5e, 0x7c, 0xae, 0xce, 0xaf, 0x5e, 0x20, 0xea, 0x42, 0x23, 0xff, 0x87, 0xaf, 0x59, 0x87,
	0xcb, 0x0b, 0xec, 0xf0, 0x5b, 0xd8, 0x70, 0x54, 0x0d, 0x12, 0x46, 0x63, 0xf6, 0xea, 0x29, 0xfa,
	0x39, 0x80, 0xf5, 0x7b, 0x46, 0x5f, 0xbe, 0x81, 0xf2, 0x36, 0x0d, 0xe6, 0x6f, 0xd3, 0x57, 0xcd,
	0xcb, 0x41, 0xff, 0xf1, 0x69, 0x2b, 0x78, 0x72, 0xda, 0x0a, 0xfe, 0x3a, 0x6d, 0x05, 0x3f, 0x9d,
	0xb5, 0x96, 0x9e, 0x9c, 0xb5, 0x96, 0xfe, 0x38, 0x6b, 0x2d, 0x7d, 0xf9, 0xf6, 0x5c, 0x5e, 0x73,
	0x67, 0x25, 0x64, 0xa4, 0xec, 0x43, 0xef, 0x78, 0xf6, 0xbd, 0x67, 0xd3, 0x8f, 0x56, 0xed, 0xc7,
	0xde, 0xfb, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xa1, 0x83, 0xb2, 0x9f, 0x71, 0x0a, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorizedMembers) > 0 {
		for iNdEx := len(m.AuthorizedMembers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthorizedMembers[iNdEx])
			copy(dAtA[i:], m.AuthorizedMembers[iNdEx])
			i = encodeVarintCaptains(dAtA, i, uint64(len(m.AuthorizedMembers[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CurrentSaleLevel != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CurrentSaleLevel))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.TechProgressCoefficientCardinality.Size()
		i -= size
		if _, err := m.TechProgressCoefficientCardinality.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.HalvingEraCoefficient.Size()
		i -= size
		if _, err := m.HalvingEraCoefficient.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size := m.CaptainsConstant.Size()
		i -= size
		if _, err := m.CaptainsConstant.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.MaximumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MaximumPowerOnPeriod))
		i--
		dAtA[i] = 0x18
	}
	if m.MinimumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MinimumPowerOnPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.CaptainsTotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CaptainsTotalCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Division) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Division) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Division) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPowerUpperBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerUpperBound))
		i--
		dAtA[i] = 0x38
	}
	if m.ComputingPowerLowerBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerLowerBound))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x28
	}
	if m.SoldCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.SoldCount))
		i--
		dAtA[i] = 0x20
	}
	if m.InitialSupply != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.InitialSupply))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPower != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DivisionId) > 0 {
		i -= len(m.DivisionId)
		copy(dAtA[i:], m.DivisionId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.DivisionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BaseState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BaseState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BaseState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportDigest != nil {
		{
			size, err := m.ReportDigest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCaptains(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	{
		size := m.GlobalClaimedEmission.Size()
		i -= size
		if _, err := m.GlobalClaimedEmission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.NextNodeSequence != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.NextNodeSequence))
		i--
		dAtA[i] = 0x18
	}
	if m.IsEpochEnd {
		i--
		if m.IsEpochEnd {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochEmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochEmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochEmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Emission.Size()
		i -= size
		if _, err := m.Emission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeClaimedEmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeClaimedEmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeClaimedEmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Emission.Size()
		i -= size
		if _, err := m.Emission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimableComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimableComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimableComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeCumulativeEmission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCumulativeEmission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCumulativeEmission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Emission.Size()
		i -= size
		if _, err := m.Emission.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodesComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodesComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodesComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobalPledge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalPledge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalPledge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OwnerPledge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerPledge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OwnerPledge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.Amount.Size()
		i -= size
		if _, err := m.Amount.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCaptains(dAtA []byte, offset int, v uint64) int {
	offset -= sovCaptains(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptainsTotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.CaptainsTotalCount))
	}
	if m.MinimumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MinimumPowerOnPeriod))
	}
	if m.MaximumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MaximumPowerOnPeriod))
	}
	l = m.CaptainsConstant.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.HalvingEraCoefficient.Size()
	n += 1 + l + sovCaptains(uint64(l))
	l = m.TechProgressCoefficientCardinality.Size()
	n += 1 + l + sovCaptains(uint64(l))
	if m.CurrentSaleLevel != 0 {
		n += 1 + sovCaptains(uint64(m.CurrentSaleLevel))
	}
	if len(m.AuthorizedMembers) > 0 {
		for _, s := range m.AuthorizedMembers {
			l = len(s)
			n += 1 + l + sovCaptains(uint64(l))
		}
	}
	return n
}

func (m *Division) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovCaptains(uint64(m.Level))
	}
	if m.InitialSupply != 0 {
		n += 1 + sovCaptains(uint64(m.InitialSupply))
	}
	if m.SoldCount != 0 {
		n += 1 + sovCaptains(uint64(m.SoldCount))
	}
	if m.TotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.TotalCount))
	}
	if m.ComputingPowerLowerBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerLowerBound))
	}
	if m.ComputingPowerUpperBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerUpperBound))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.DivisionId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.ComputingPower != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPower))
	}
	return n
}

func (m *BaseState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	if m.IsEpochEnd {
		n += 2
	}
	if m.NextNodeSequence != 0 {
		n += 1 + sovCaptains(uint64(m.NextNodeSequence))
	}
	l = m.GlobalClaimedEmission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	if m.ReportDigest != nil {
		l = m.ReportDigest.Size()
		n += 1 + l + sovCaptains(uint64(l))
	}
	return n
}

func (m *EpochEmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Emission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *NodeClaimedEmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = m.Emission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *ClaimableComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovCaptains(uint64(m.Amount))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	return n
}

func (m *NodeCumulativeEmission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Emission.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *GlobalComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *NodesComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *GlobalPledge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *OwnerPledge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	l = m.Amount.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func sovCaptains(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCaptains(x uint64) (n int) {
	return sovCaptains(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsTotalCount", wireType)
			}
			m.CaptainsTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainsTotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumPowerOnPeriod", wireType)
			}
			m.MinimumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPowerOnPeriod", wireType)
			}
			m.MaximumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsConstant", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CaptainsConstant.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalvingEraCoefficient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HalvingEraCoefficient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TechProgressCoefficientCardinality", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TechProgressCoefficientCardinality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSaleLevel", wireType)
			}
			m.CurrentSaleLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSaleLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizedMembers = append(m.AuthorizedMembers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Division) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Division: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Division: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSupply", wireType)
			}
			m.InitialSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldCount", wireType)
			}
			m.SoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerLowerBound", wireType)
			}
			m.ComputingPowerLowerBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerLowerBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerUpperBound", wireType)
			}
			m.ComputingPowerUpperBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerUpperBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DivisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPower", wireType)
			}
			m.ComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BaseState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BaseState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BaseState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEpochEnd", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEpochEnd = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextNodeSequence", wireType)
			}
			m.NextNodeSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextNodeSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalClaimedEmission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GlobalClaimedEmission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDigest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportDigest == nil {
				m.ReportDigest = &ReportDigest{}
			}
			if err := m.ReportDigest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochEmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochEmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochEmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Emission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeClaimedEmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeClaimedEmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeClaimedEmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Emission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimableComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimableComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimableComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCumulativeEmission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCumulativeEmission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCumulativeEmission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emission", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Emission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalPledge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalPledge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalPledge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerPledge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerPledge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerPledge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCaptains(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCaptains
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCaptains
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCaptains
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCaptains        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCaptains          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCaptains = fmt.Errorf("proto: unexpected end of group")
)
