// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tabi/captains/v1/captains.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines captains module's parameters
type Params struct {
	// captains_total_count defines the total count of the captains
	CaptainsTotalCount uint64 `protobuf:"varint,1,opt,name=captains_total_count,json=captainsTotalCount,proto3" json:"captains_total_count,omitempty"`
	// minimum_power_on_period defines the minimum period for a captain to be powered on
	MinimumPowerOnPeriod uint64 `protobuf:"varint,2,opt,name=minimum_power_on_period,json=minimumPowerOnPeriod,proto3" json:"minimum_power_on_period,omitempty"`
	// maximum_power_on_period defines the maximum period for a captain to be powered on
	MaximumPowerOnPeriod uint64 `protobuf:"varint,3,opt,name=maximum_power_on_period,json=maximumPowerOnPeriod,proto3" json:"maximum_power_on_period,omitempty"`
	// captains_constant is a fixed constant for reward calculation
	CaptainsConstant uint64 `protobuf:"varint,4,opt,name=captains_constant,json=captainsConstant,proto3" json:"captains_constant,omitempty"`
	// maximum_number_of_holdings defines the maximum number of captain nodes one account can hold.
	MaximumHoldingAmount uint64 `protobuf:"varint,5,opt,name=maximum_holding_amount,json=maximumHoldingAmount,proto3" json:"maximum_holding_amount,omitempty"`
	// halving_era defines the halving era coefficient
	HalvingEraCoefficient github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=halving_era_coefficient,json=halvingEraCoefficient,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"halving_era_coefficient"`
	// current_sale_level defines the current level for sale.
	CurrentSaleLevel uint64 `protobuf:"varint,7,opt,name=current_sale_level,json=currentSaleLevel,proto3" json:"current_sale_level,omitempty"`
	// authorized members list
	AuthorizedMembers []string `protobuf:"bytes,8,rep,name=authorized_members,json=authorizedMembers,proto3" json:"authorized_members,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetCaptainsTotalCount() uint64 {
	if m != nil {
		return m.CaptainsTotalCount
	}
	return 0
}

func (m *Params) GetMinimumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MinimumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetMaximumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MaximumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetCaptainsConstant() uint64 {
	if m != nil {
		return m.CaptainsConstant
	}
	return 0
}

func (m *Params) GetMaximumHoldingAmount() uint64 {
	if m != nil {
		return m.MaximumHoldingAmount
	}
	return 0
}

func (m *Params) GetCurrentSaleLevel() uint64 {
	if m != nil {
		return m.CurrentSaleLevel
	}
	return 0
}

func (m *Params) GetAuthorizedMembers() []string {
	if m != nil {
		return m.AuthorizedMembers
	}
	return nil
}

// Division defines the division a node belongs to.
type Division struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// level defines the level of the node.
	Level uint64 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	// initial_supply defines the initial supply of the node in the division.
	InitialSupply uint64 `protobuf:"varint,3,opt,name=initial_supply,json=initialSupply,proto3" json:"initial_supply,omitempty"`
	// sold_count defines the total count of the node in the division.
	SoldCount uint64 `protobuf:"varint,4,opt,name=sold_count,json=soldCount,proto3" json:"sold_count,omitempty"`
	// total_count defines the supply count of nodes in the division.
	TotalCount uint64 `protobuf:"varint,5,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// computing_power_lower_bound defines the low bound of computing power in the division.
	ComputingPowerLowerBound uint64 `protobuf:"varint,6,opt,name=computing_power_lower_bound,json=computingPowerLowerBound,proto3" json:"computing_power_lower_bound,omitempty"`
	// computing_power_upper_bound defines the upper bound of computing power in the division.
	ComputingPowerUpperBound uint64 `protobuf:"varint,7,opt,name=computing_power_upper_bound,json=computingPowerUpperBound,proto3" json:"computing_power_upper_bound,omitempty"`
}

func (m *Division) Reset()         { *m = Division{} }
func (m *Division) String() string { return proto.CompactTextString(m) }
func (*Division) ProtoMessage()    {}
func (*Division) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{1}
}
func (m *Division) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Division) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Division.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Division) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Division.Merge(m, src)
}
func (m *Division) XXX_Size() int {
	return m.Size()
}
func (m *Division) XXX_DiscardUnknown() {
	xxx_messageInfo_Division.DiscardUnknown(m)
}

var xxx_messageInfo_Division proto.InternalMessageInfo

func (m *Division) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Division) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Division) GetInitialSupply() uint64 {
	if m != nil {
		return m.InitialSupply
	}
	return 0
}

func (m *Division) GetSoldCount() uint64 {
	if m != nil {
		return m.SoldCount
	}
	return 0
}

func (m *Division) GetTotalCount() uint64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *Division) GetComputingPowerLowerBound() uint64 {
	if m != nil {
		return m.ComputingPowerLowerBound
	}
	return 0
}

func (m *Division) GetComputingPowerUpperBound() uint64 {
	if m != nil {
		return m.ComputingPowerUpperBound
	}
	return 0
}

// Node defines the node
type Node struct {
	Id             string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DivisionId     string `protobuf:"bytes,2,opt,name=division_id,json=divisionId,proto3" json:"division_id,omitempty"`
	Owner          string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	ComputingPower uint64 `protobuf:"varint,4,opt,name=computing_power,json=computingPower,proto3" json:"computing_power,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetDivisionId() string {
	if m != nil {
		return m.DivisionId
	}
	return ""
}

func (m *Node) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Node) GetComputingPower() uint64 {
	if m != nil {
		return m.ComputingPower
	}
	return 0
}

// EpochInfo defines the epoch information
type Epoch struct {
	EpochId               uint64     `protobuf:"varint,1,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	StartHeight           uint64     `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height,omitempty"`
	EndHeight             uint64     `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height,omitempty"`
	HistoricalEmissionSum uint64     `protobuf:"varint,4,opt,name=historical_emission_sum,json=historicalEmissionSum,proto3" json:"historical_emission_sum,omitempty"`
	ComputingPowerSum     uint64     `protobuf:"varint,5,opt,name=computing_power_sum,json=computingPowerSum,proto3" json:"computing_power_sum,omitempty"`
	PledgeAmountSum       uint64     `protobuf:"varint,6,opt,name=pledge_amount_sum,json=pledgeAmountSum,proto3" json:"pledge_amount_sum,omitempty"`
	EpochState            EpochState `protobuf:"bytes,7,opt,name=epoch_state,json=epochState,proto3" json:"epoch_state"`
}

func (m *Epoch) Reset()         { *m = Epoch{} }
func (m *Epoch) String() string { return proto.CompactTextString(m) }
func (*Epoch) ProtoMessage()    {}
func (*Epoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{3}
}
func (m *Epoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Epoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Epoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Epoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Epoch.Merge(m, src)
}
func (m *Epoch) XXX_Size() int {
	return m.Size()
}
func (m *Epoch) XXX_DiscardUnknown() {
	xxx_messageInfo_Epoch.DiscardUnknown(m)
}

var xxx_messageInfo_Epoch proto.InternalMessageInfo

func (m *Epoch) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *Epoch) GetStartHeight() uint64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *Epoch) GetEndHeight() uint64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *Epoch) GetHistoricalEmissionSum() uint64 {
	if m != nil {
		return m.HistoricalEmissionSum
	}
	return 0
}

func (m *Epoch) GetComputingPowerSum() uint64 {
	if m != nil {
		return m.ComputingPowerSum
	}
	return 0
}

func (m *Epoch) GetPledgeAmountSum() uint64 {
	if m != nil {
		return m.PledgeAmountSum
	}
	return 0
}

func (m *Epoch) GetEpochState() EpochState {
	if m != nil {
		return m.EpochState
	}
	return EpochState{}
}

// EpochState defines the epoch state
type EpochState struct {
	Completed                      uint64 `protobuf:"varint,1,opt,name=completed,proto3" json:"completed,omitempty"`
	ReportValidationCount          uint64 `protobuf:"varint,2,opt,name=report_validation_count,json=reportValidationCount,proto3" json:"report_validation_count,omitempty"`
	ComputingPowerCalculationCount uint64 `protobuf:"varint,3,opt,name=computing_power_calculation_count,json=computingPowerCalculationCount,proto3" json:"computing_power_calculation_count,omitempty"`
	RewardCalculationCount         uint64 `protobuf:"varint,4,opt,name=reward_calculation_count,json=rewardCalculationCount,proto3" json:"reward_calculation_count,omitempty"`
}

func (m *EpochState) Reset()         { *m = EpochState{} }
func (m *EpochState) String() string { return proto.CompactTextString(m) }
func (*EpochState) ProtoMessage()    {}
func (*EpochState) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{4}
}
func (m *EpochState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EpochState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EpochState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EpochState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EpochState.Merge(m, src)
}
func (m *EpochState) XXX_Size() int {
	return m.Size()
}
func (m *EpochState) XXX_DiscardUnknown() {
	xxx_messageInfo_EpochState.DiscardUnknown(m)
}

var xxx_messageInfo_EpochState proto.InternalMessageInfo

func (m *EpochState) GetCompleted() uint64 {
	if m != nil {
		return m.Completed
	}
	return 0
}

func (m *EpochState) GetReportValidationCount() uint64 {
	if m != nil {
		return m.ReportValidationCount
	}
	return 0
}

func (m *EpochState) GetComputingPowerCalculationCount() uint64 {
	if m != nil {
		return m.ComputingPowerCalculationCount
	}
	return 0
}

func (m *EpochState) GetRewardCalculationCount() uint64 {
	if m != nil {
		return m.RewardCalculationCount
	}
	return 0
}

// NodeEpochInfo defines the node info on epoch
type NodeEpochInfo struct {
	Id                 string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	EpochId            uint64 `protobuf:"varint,2,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	HistoricalEmission uint64 `protobuf:"varint,3,opt,name=historical_emission,json=historicalEmission,proto3" json:"historical_emission,omitempty"`
	ComputingPower     uint64 `protobuf:"varint,4,opt,name=computing_power,json=computingPower,proto3" json:"computing_power,omitempty"`
}

func (m *NodeEpochInfo) Reset()         { *m = NodeEpochInfo{} }
func (m *NodeEpochInfo) String() string { return proto.CompactTextString(m) }
func (*NodeEpochInfo) ProtoMessage()    {}
func (*NodeEpochInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{5}
}
func (m *NodeEpochInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeEpochInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeEpochInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeEpochInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeEpochInfo.Merge(m, src)
}
func (m *NodeEpochInfo) XXX_Size() int {
	return m.Size()
}
func (m *NodeEpochInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeEpochInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NodeEpochInfo proto.InternalMessageInfo

func (m *NodeEpochInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *NodeEpochInfo) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *NodeEpochInfo) GetHistoricalEmission() uint64 {
	if m != nil {
		return m.HistoricalEmission
	}
	return 0
}

func (m *NodeEpochInfo) GetComputingPower() uint64 {
	if m != nil {
		return m.ComputingPower
	}
	return 0
}

// ClaimableComputingPower defines claimable reward of computing power to the owner.
type ClaimableComputingPower struct {
	Amount uint64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	Owner  string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (m *ClaimableComputingPower) Reset()         { *m = ClaimableComputingPower{} }
func (m *ClaimableComputingPower) String() string { return proto.CompactTextString(m) }
func (*ClaimableComputingPower) ProtoMessage()    {}
func (*ClaimableComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_35d5085f64c624e4, []int{6}
}
func (m *ClaimableComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimableComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimableComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimableComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimableComputingPower.Merge(m, src)
}
func (m *ClaimableComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *ClaimableComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimableComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimableComputingPower proto.InternalMessageInfo

func (m *ClaimableComputingPower) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *ClaimableComputingPower) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func init() {
	proto.RegisterType((*Params)(nil), "tabi.captains.v1.Params")
	proto.RegisterType((*Division)(nil), "tabi.captains.v1.Division")
	proto.RegisterType((*Node)(nil), "tabi.captains.v1.Node")
	proto.RegisterType((*Epoch)(nil), "tabi.captains.v1.Epoch")
	proto.RegisterType((*EpochState)(nil), "tabi.captains.v1.EpochState")
	proto.RegisterType((*NodeEpochInfo)(nil), "tabi.captains.v1.NodeEpochInfo")
	proto.RegisterType((*ClaimableComputingPower)(nil), "tabi.captains.v1.ClaimableComputingPower")
}

func init() { proto.RegisterFile("tabi/captains/v1/captains.proto", fileDescriptor_35d5085f64c624e4) }

var fileDescriptor_35d5085f64c624e4 = []byte{
	// 909 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x55, 0x4b, 0x73, 0x5b, 0x35,
	0x14, 0x8e, 0x1d, 0xe7, 0xe1, 0x63, 0x9a, 0x36, 0xaa, 0x93, 0xdc, 0x96, 0x62, 0xa7, 0x9e, 0x01,
	0xc2, 0x23, 0x36, 0xe5, 0x35, 0x2c, 0x60, 0x51, 0x3b, 0x99, 0x69, 0x66, 0x0a, 0x64, 0xae, 0x81,
	0x05, 0x9b, 0x3b, 0xf2, 0x95, 0x62, 0x6b, 0xd0, 0x95, 0xee, 0x48, 0xba, 0x4e, 0xcb, 0xaf, 0x60,
	0x01, 0xff, 0xa4, 0x5b, 0xf6, 0x5d, 0x76, 0xb2, 0x62, 0x58, 0x64, 0x98, 0x64, 0xc1, 0xdf, 0x60,
	0xf4, 0xb0, 0x1d, 0x3b, 0x5e, 0xb0, 0xb1, 0xa5, 0xf3, 0x9d, 0xa3, 0xc7, 0xf7, 0x7d, 0x47, 0x17,
	0x9a, 0x06, 0x0f, 0x58, 0x27, 0xc5, 0xb9, 0xc1, 0x4c, 0xe8, 0xce, 0xf8, 0xc9, 0x74, 0xdc, 0xce,
	0x95, 0x34, 0x12, 0xdd, 0xb3, 0x09, 0xed, 0x69, 0x70, 0xfc, 0xe4, 0x61, 0x7d, 0x28, 0x87, 0xd2,
	0x81, 0x1d, 0x3b, 0xf2, 0x79, 0x0f, 0x1f, 0xa4, 0x52, 0x67, 0x52, 0x27, 0x1e, 0xf0, 0x13, 0x0f,
	0xb5, 0x2e, 0x57, 0x61, 0xfd, 0x14, 0x2b, 0x9c, 0x69, 0xf4, 0x09, 0xd4, 0x27, 0x4b, 0x25, 0x46,
	0x1a, 0xcc, 0x93, 0x54, 0x16, 0xc2, 0x44, 0xa5, 0xfd, 0xd2, 0x41, 0x25, 0x46, 0x13, 0xec, 0x07,
	0x0b, 0xf5, 0x2c, 0x82, 0xbe, 0x80, 0xbd, 0x8c, 0x09, 0x96, 0x15, 0x59, 0x92, 0xcb, 0x73, 0xaa,
	0x12, 0x29, 0x92, 0x9c, 0x2a, 0x26, 0x49, 0x54, 0x76, 0x45, 0xf5, 0x00, 0x9f, 0x5a, 0xf4, 0x7b,
	0x71, 0xea, 0x30, 0x57, 0x86, 0x5f, 0x2c, 0x2d, 0x5b, 0x0d, 0x65, 0x1e, 0x9e, 0x2f, 0xfb, 0x08,
	0xb6, 0xa7, 0xe7, 0x4b, 0xa5, 0xd0, 0x06, 0x0b, 0x13, 0x55, 0x5c, 0xc1, 0xbd, 0x09, 0xd0, 0x0b,
	0x71, 0xf4, 0x39, 0xec, 0x4e, 0xf6, 0x18, 0x49, 0x4e, 0x98, 0x18, 0x26, 0x38, 0x73, 0xd7, 0x59,
	0x9b, 0xdb, 0xe2, 0x99, 0x07, 0x9f, 0x3a, 0x0c, 0x19, 0xd8, 0x1b, 0x61, 0x3e, 0xb6, 0xd9, 0x54,
	0xe1, 0x24, 0x95, 0xf4, 0xec, 0x8c, 0xa5, 0x8c, 0x0a, 0x13, 0xad, 0xef, 0x97, 0x0e, 0xaa, 0xdd,
	0xaf, 0x5f, 0x5f, 0x36, 0x57, 0xfe, 0xbe, 0x6c, 0xbe, 0x37, 0x64, 0x66, 0x54, 0x0c, 0xda, 0xa9,
	0xcc, 0x02, 0x9f, 0xe1, 0xef, 0x50, 0x93, 0x5f, 0x3a, 0xe6, 0x65, 0x4e, 0x75, 0xfb, 0x88, 0xa6,
	0x17, 0xaf, 0x0e, 0x21, 0xd0, 0x7d, 0x44, 0xd3, 0x78, 0x27, 0x2c, 0x7e, 0xac, 0x70, 0x6f, 0xb6,
	0x34, 0xfa, 0x18, 0x50, 0x5a, 0x28, 0x45, 0x85, 0x49, 0x34, 0xe6, 0x34, 0xe1, 0x74, 0x4c, 0x79,
	0xb4, 0x11, 0x6e, 0xe6, 0x91, 0x3e, 0xe6, 0xf4, 0xb9, 0x8d, 0xa3, 0x43, 0x40, 0xb8, 0x30, 0x23,
	0xa9, 0xd8, 0xaf, 0x94, 0x24, 0x19, 0xcd, 0x06, 0x54, 0xe9, 0x68, 0x73, 0x7f, 0xf5, 0xa0, 0x1a,
	0x6f, 0xcf, 0x90, 0x6f, 0x3d, 0xd0, 0xfa, 0xa3, 0x0c, 0x9b, 0x47, 0x6c, 0xcc, 0x34, 0x93, 0x02,
	0x6d, 0x41, 0x99, 0x11, 0x27, 0x68, 0x35, 0x2e, 0x33, 0x82, 0xea, 0xb0, 0xe6, 0x37, 0xf3, 0x72,
	0xf9, 0x09, 0x7a, 0x17, 0xb6, 0x98, 0x60, 0x86, 0x61, 0x9e, 0xe8, 0x22, 0xcf, 0xf9, 0xcb, 0x20,
	0xcb, 0x9d, 0x10, 0xed, 0xbb, 0x20, 0x7a, 0x07, 0x40, 0x4b, 0x4e, 0x82, 0x4b, 0xbc, 0x10, 0x55,
	0x1b, 0xf1, 0xe6, 0x68, 0x42, 0xed, 0xa6, 0x8b, 0x3c, 0xed, 0x60, 0x66, 0xee, 0xf9, 0x06, 0xde,
	0x4e, 0x65, 0x96, 0x17, 0xc6, 0xd2, 0xed, 0x8d, 0xc0, 0xdd, 0xef, 0x40, 0x16, 0x82, 0x38, 0xc2,
	0x2b, 0x71, 0x34, 0x4d, 0x71, 0x66, 0x78, 0x6e, 0x7f, 0xba, 0x16, 0x5f, 0x56, 0x5e, 0xe4, 0xf9,
	0xb4, 0x7c, 0x63, 0x59, 0xf9, 0x8f, 0x36, 0xc1, 0x95, 0xb7, 0xc6, 0x50, 0xf9, 0x4e, 0x12, 0x7a,
	0x8b, 0x92, 0x26, 0xd4, 0x48, 0xa0, 0x2b, 0x61, 0xde, 0xc7, 0xd5, 0x18, 0x26, 0xa1, 0x13, 0xc7,
	0x99, 0x3c, 0x17, 0x54, 0x39, 0x52, 0xaa, 0xb1, 0x9f, 0xa0, 0xf7, 0xe1, 0xee, 0xc2, 0x69, 0x02,
	0x23, 0x5b, 0xf3, 0x27, 0x68, 0xfd, 0x59, 0x86, 0xb5, 0xe3, 0x5c, 0xa6, 0x23, 0xf4, 0x00, 0x36,
	0xa9, 0x1d, 0x24, 0x61, 0xff, 0x4a, 0xbc, 0xe1, 0xe6, 0x27, 0x04, 0x3d, 0x86, 0xb7, 0xb4, 0xc1,
	0xca, 0x24, 0x23, 0xca, 0x86, 0x23, 0x13, 0xe4, 0xa9, 0xb9, 0xd8, 0x33, 0x17, 0xb2, 0xec, 0x53,
	0x41, 0x26, 0x09, 0x5e, 0xa0, 0x2a, 0x15, 0x24, 0xc0, 0x5f, 0xc2, 0xde, 0x88, 0x69, 0x23, 0x15,
	0x4b, 0x31, 0x4f, 0x68, 0xc6, 0xb4, 0xbb, 0x91, 0x2e, 0xb2, 0x70, 0xae, 0x9d, 0x19, 0x7c, 0x1c,
	0xd0, 0x7e, 0x91, 0xa1, 0x36, 0xdc, 0x5f, 0x64, 0xd5, 0xd6, 0x78, 0xf5, 0xb6, 0xe7, 0xef, 0x62,
	0xf3, 0x3f, 0x84, 0xed, 0x9c, 0x53, 0x32, 0xa4, 0xa1, 0xbd, 0x5c, 0xb6, 0x97, 0xee, 0xae, 0x07,
	0x7c, 0x6b, 0xd9, 0xdc, 0x1e, 0xd4, 0xfc, 0x85, 0xb5, 0xc1, 0x86, 0x3a, 0x85, 0x6a, 0x9f, 0x3e,
	0x6a, 0x2f, 0x3e, 0x62, 0x6d, 0x47, 0x4f, 0xdf, 0xe6, 0x74, 0x2b, 0xb6, 0xdf, 0x62, 0xa0, 0xd3,
	0x48, 0xeb, 0xdf, 0x12, 0xc0, 0x2c, 0x01, 0x3d, 0x82, 0xaa, 0x3d, 0x14, 0xa7, 0x86, 0x4e, 0x58,
	0x9c, 0x05, 0x2c, 0x0b, 0x8a, 0xe6, 0x52, 0x99, 0x64, 0x8c, 0x39, 0x23, 0xd8, 0x58, 0x0e, 0xbc,
	0x1f, 0x3d, 0xa5, 0x3b, 0x1e, 0xfe, 0x69, 0x8a, 0x7a, 0x6b, 0x9e, 0xc0, 0xe3, 0x45, 0x16, 0x52,
	0xcc, 0xd3, 0x82, 0xdf, 0x5c, 0xc1, 0x73, 0xde, 0x98, 0xe7, 0xa4, 0x37, 0x4b, 0xf3, 0x4b, 0x7d,
	0x05, 0x91, 0xa2, 0xe7, 0x58, 0x91, 0x25, 0x2b, 0x78, 0x25, 0x76, 0x3d, 0xbe, 0x58, 0xd9, 0xfa,
	0xbd, 0x04, 0x77, 0xac, 0x45, 0xdd, 0x6d, 0x4f, 0xc4, 0x99, 0xbc, 0xe5, 0xd5, 0x9b, 0x0e, 0x2a,
	0xcf, 0x3b, 0xa8, 0x03, 0xf7, 0x97, 0xe8, 0x1f, 0xce, 0x8c, 0x6e, 0x6b, 0xff, 0xff, 0x0d, 0x8c,
	0x61, 0xaf, 0xc7, 0x31, 0xcb, 0xf0, 0x80, 0xd3, 0xde, 0x1c, 0x84, 0x76, 0x61, 0x3d, 0x3c, 0xb2,
	0x5e, 0x89, 0x30, 0x43, 0xed, 0x49, 0xcb, 0xb8, 0x6e, 0xea, 0x46, 0x17, 0xaf, 0x0e, 0xeb, 0xe1,
	0x59, 0x7c, 0x4a, 0x88, 0xa2, 0x5a, 0xf7, 0x8d, 0x62, 0x62, 0x18, 0x9a, 0xa9, 0xdb, 0x7b, 0x7d,
	0xd5, 0x28, 0xbd, 0xb9, 0x6a, 0x94, 0xfe, 0xb9, 0x6a, 0x94, 0x7e, 0xbb, 0x6e, 0xac, 0xbc, 0xb9,
	0x6e, 0xac, 0xfc, 0x75, 0xdd, 0x58, 0xf9, 0xf9, 0x83, 0x1b, 0xef, 0xae, 0xf5, 0x0d, 0xc7, 0x03,
	0xed, 0x06, 0x9d, 0x17, 0xb3, 0x0f, 0xa5, 0x7b, 0x7e, 0x07, 0xeb, 0xee, 0x03, 0xf7, 0xd9, 0x7f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0xc0, 0xe9, 0x33, 0xfb, 0x46, 0x07, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthorizedMembers) > 0 {
		for iNdEx := len(m.AuthorizedMembers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AuthorizedMembers[iNdEx])
			copy(dAtA[i:], m.AuthorizedMembers[iNdEx])
			i = encodeVarintCaptains(dAtA, i, uint64(len(m.AuthorizedMembers[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.CurrentSaleLevel != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CurrentSaleLevel))
		i--
		dAtA[i] = 0x38
	}
	{
		size := m.HalvingEraCoefficient.Size()
		i -= size
		if _, err := m.HalvingEraCoefficient.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.MaximumHoldingAmount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MaximumHoldingAmount))
		i--
		dAtA[i] = 0x28
	}
	if m.CaptainsConstant != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CaptainsConstant))
		i--
		dAtA[i] = 0x20
	}
	if m.MaximumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MaximumPowerOnPeriod))
		i--
		dAtA[i] = 0x18
	}
	if m.MinimumPowerOnPeriod != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.MinimumPowerOnPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.CaptainsTotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.CaptainsTotalCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Division) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Division) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Division) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPowerUpperBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerUpperBound))
		i--
		dAtA[i] = 0x38
	}
	if m.ComputingPowerLowerBound != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerLowerBound))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x28
	}
	if m.SoldCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.SoldCount))
		i--
		dAtA[i] = 0x20
	}
	if m.InitialSupply != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.InitialSupply))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPower != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DivisionId) > 0 {
		i -= len(m.DivisionId)
		copy(dAtA[i:], m.DivisionId)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.DivisionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Epoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Epoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Epoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.EpochState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCaptains(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.PledgeAmountSum != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.PledgeAmountSum))
		i--
		dAtA[i] = 0x30
	}
	if m.ComputingPowerSum != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerSum))
		i--
		dAtA[i] = 0x28
	}
	if m.HistoricalEmissionSum != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.HistoricalEmissionSum))
		i--
		dAtA[i] = 0x20
	}
	if m.EndHeight != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EpochState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EpochState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EpochState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RewardCalculationCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.RewardCalculationCount))
		i--
		dAtA[i] = 0x20
	}
	if m.ComputingPowerCalculationCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPowerCalculationCount))
		i--
		dAtA[i] = 0x18
	}
	if m.ReportValidationCount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ReportValidationCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Completed != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Completed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeEpochInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeEpochInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeEpochInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPower != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.ComputingPower))
		i--
		dAtA[i] = 0x20
	}
	if m.HistoricalEmission != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.HistoricalEmission))
		i--
		dAtA[i] = 0x18
	}
	if m.EpochId != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimableComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimableComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimableComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptains(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if m.Amount != 0 {
		i = encodeVarintCaptains(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCaptains(dAtA []byte, offset int, v uint64) int {
	offset -= sovCaptains(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CaptainsTotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.CaptainsTotalCount))
	}
	if m.MinimumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MinimumPowerOnPeriod))
	}
	if m.MaximumPowerOnPeriod != 0 {
		n += 1 + sovCaptains(uint64(m.MaximumPowerOnPeriod))
	}
	if m.CaptainsConstant != 0 {
		n += 1 + sovCaptains(uint64(m.CaptainsConstant))
	}
	if m.MaximumHoldingAmount != 0 {
		n += 1 + sovCaptains(uint64(m.MaximumHoldingAmount))
	}
	l = m.HalvingEraCoefficient.Size()
	n += 1 + l + sovCaptains(uint64(l))
	if m.CurrentSaleLevel != 0 {
		n += 1 + sovCaptains(uint64(m.CurrentSaleLevel))
	}
	if len(m.AuthorizedMembers) > 0 {
		for _, s := range m.AuthorizedMembers {
			l = len(s)
			n += 1 + l + sovCaptains(uint64(l))
		}
	}
	return n
}

func (m *Division) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovCaptains(uint64(m.Level))
	}
	if m.InitialSupply != 0 {
		n += 1 + sovCaptains(uint64(m.InitialSupply))
	}
	if m.SoldCount != 0 {
		n += 1 + sovCaptains(uint64(m.SoldCount))
	}
	if m.TotalCount != 0 {
		n += 1 + sovCaptains(uint64(m.TotalCount))
	}
	if m.ComputingPowerLowerBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerLowerBound))
	}
	if m.ComputingPowerUpperBound != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerUpperBound))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.DivisionId)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.ComputingPower != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPower))
	}
	return n
}

func (m *Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	if m.StartHeight != 0 {
		n += 1 + sovCaptains(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovCaptains(uint64(m.EndHeight))
	}
	if m.HistoricalEmissionSum != 0 {
		n += 1 + sovCaptains(uint64(m.HistoricalEmissionSum))
	}
	if m.ComputingPowerSum != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerSum))
	}
	if m.PledgeAmountSum != 0 {
		n += 1 + sovCaptains(uint64(m.PledgeAmountSum))
	}
	l = m.EpochState.Size()
	n += 1 + l + sovCaptains(uint64(l))
	return n
}

func (m *EpochState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Completed != 0 {
		n += 1 + sovCaptains(uint64(m.Completed))
	}
	if m.ReportValidationCount != 0 {
		n += 1 + sovCaptains(uint64(m.ReportValidationCount))
	}
	if m.ComputingPowerCalculationCount != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPowerCalculationCount))
	}
	if m.RewardCalculationCount != 0 {
		n += 1 + sovCaptains(uint64(m.RewardCalculationCount))
	}
	return n
}

func (m *NodeEpochInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	if m.EpochId != 0 {
		n += 1 + sovCaptains(uint64(m.EpochId))
	}
	if m.HistoricalEmission != 0 {
		n += 1 + sovCaptains(uint64(m.HistoricalEmission))
	}
	if m.ComputingPower != 0 {
		n += 1 + sovCaptains(uint64(m.ComputingPower))
	}
	return n
}

func (m *ClaimableComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != 0 {
		n += 1 + sovCaptains(uint64(m.Amount))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptains(uint64(l))
	}
	return n
}

func sovCaptains(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCaptains(x uint64) (n int) {
	return sovCaptains(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsTotalCount", wireType)
			}
			m.CaptainsTotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainsTotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumPowerOnPeriod", wireType)
			}
			m.MinimumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPowerOnPeriod", wireType)
			}
			m.MaximumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptainsConstant", wireType)
			}
			m.CaptainsConstant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptainsConstant |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumHoldingAmount", wireType)
			}
			m.MaximumHoldingAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumHoldingAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalvingEraCoefficient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.HalvingEraCoefficient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSaleLevel", wireType)
			}
			m.CurrentSaleLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentSaleLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorizedMembers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthorizedMembers = append(m.AuthorizedMembers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Division) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Division: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Division: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialSupply", wireType)
			}
			m.InitialSupply = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialSupply |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldCount", wireType)
			}
			m.SoldCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SoldCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerLowerBound", wireType)
			}
			m.ComputingPowerLowerBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerLowerBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerUpperBound", wireType)
			}
			m.ComputingPowerUpperBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerUpperBound |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DivisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPower", wireType)
			}
			m.ComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Epoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Epoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Epoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalEmissionSum", wireType)
			}
			m.HistoricalEmissionSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoricalEmissionSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerSum", wireType)
			}
			m.ComputingPowerSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PledgeAmountSum", wireType)
			}
			m.PledgeAmountSum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PledgeAmountSum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EpochState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EpochState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EpochState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EpochState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			m.Completed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Completed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportValidationCount", wireType)
			}
			m.ReportValidationCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportValidationCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPowerCalculationCount", wireType)
			}
			m.ComputingPowerCalculationCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPowerCalculationCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardCalculationCount", wireType)
			}
			m.RewardCalculationCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardCalculationCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeEpochInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeEpochInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeEpochInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoricalEmission", wireType)
			}
			m.HistoricalEmission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HistoricalEmission |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPower", wireType)
			}
			m.ComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimableComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimableComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimableComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptains
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptains
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptains(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptains
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCaptains(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCaptains
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptains
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCaptains
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCaptains
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCaptains
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCaptains        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCaptains          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCaptains = fmt.Errorf("proto: unexpected end of group")
)
