// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: tabi/captain-node/v1/captain-node.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines captain-node module's parameters
type Params struct {
	// total_count_captains defines the total count of the captains
	TotalCountCaptains uint64 `protobuf:"varint,1,opt,name=total_count_captains,json=totalCountCaptains,proto3" json:"total_count_captains,omitempty"`
	// minimum_power_on_period defines the minimum period for a captain to be powered on
	MinimumPowerOnPeriod uint64 `protobuf:"varint,2,opt,name=minimum_power_on_period,json=minimumPowerOnPeriod,proto3" json:"minimum_power_on_period,omitempty"`
	// maximum_power_on_period defines the maximum period for a captain to be powered on
	MaximumPowerOnPeriod uint64 `protobuf:"varint,3,opt,name=maximum_power_on_period,json=maximumPowerOnPeriod,proto3" json:"maximum_power_on_period,omitempty"`
	// constant_a defines the constant a for the captain can get the reward from the network
	ConstantA uint64 `protobuf:"varint,4,opt,name=constant_a,json=constantA,proto3" json:"constant_a,omitempty"`
	// current_level_for_sale defines the current level for sale
	CurrentLevelForSale uint64 `protobuf:"varint,5,opt,name=current_level_for_sale,json=currentLevelForSale,proto3" json:"current_level_for_sale,omitempty"`
	// maximum_number_of_holdings defines the maximum number of holdings for a captain
	MaximumNumberOfHoldings uint64 `protobuf:"varint,6,opt,name=maximum_number_of_holdings,json=maximumNumberOfHoldings,proto3" json:"maximum_number_of_holdings,omitempty"`
	// halving_era defines the halving era
	HalvingEra uint64 `protobuf:"varint,7,opt,name=halving_era,json=halvingEra,proto3" json:"halving_era,omitempty"`
	// authorized caller list
	Callers []string `protobuf:"bytes,8,rep,name=callers,proto3" json:"callers,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb21c7c329a6c9e, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetTotalCountCaptains() uint64 {
	if m != nil {
		return m.TotalCountCaptains
	}
	return 0
}

func (m *Params) GetMinimumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MinimumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetMaximumPowerOnPeriod() uint64 {
	if m != nil {
		return m.MaximumPowerOnPeriod
	}
	return 0
}

func (m *Params) GetConstantA() uint64 {
	if m != nil {
		return m.ConstantA
	}
	return 0
}

func (m *Params) GetCurrentLevelForSale() uint64 {
	if m != nil {
		return m.CurrentLevelForSale
	}
	return 0
}

func (m *Params) GetMaximumNumberOfHoldings() uint64 {
	if m != nil {
		return m.MaximumNumberOfHoldings
	}
	return 0
}

func (m *Params) GetHalvingEra() uint64 {
	if m != nil {
		return m.HalvingEra
	}
	return 0
}

func (m *Params) GetCallers() []string {
	if m != nil {
		return m.Callers
	}
	return nil
}

// Rank defines the node class
type Division struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// level defines the level of the node
	Level uint64 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	// total_count defines the total count of the node
	TotalCount uint64 `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// low_computing_power defines the low computing power of the node
	LowComputingPower uint64 `protobuf:"varint,4,opt,name=low_computing_power,json=lowComputingPower,proto3" json:"low_computing_power,omitempty"`
	// high_computing_power defines the high computing power of the node
	HighComputingPower uint64 `protobuf:"varint,5,opt,name=high_computing_power,json=highComputingPower,proto3" json:"high_computing_power,omitempty"`
}

func (m *Division) Reset()         { *m = Division{} }
func (m *Division) String() string { return proto.CompactTextString(m) }
func (*Division) ProtoMessage()    {}
func (*Division) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb21c7c329a6c9e, []int{1}
}
func (m *Division) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Division) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Division.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Division) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Division.Merge(m, src)
}
func (m *Division) XXX_Size() int {
	return m.Size()
}
func (m *Division) XXX_DiscardUnknown() {
	xxx_messageInfo_Division.DiscardUnknown(m)
}

var xxx_messageInfo_Division proto.InternalMessageInfo

func (m *Division) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Division) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Division) GetTotalCount() uint64 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *Division) GetLowComputingPower() uint64 {
	if m != nil {
		return m.LowComputingPower
	}
	return 0
}

func (m *Division) GetHighComputingPower() uint64 {
	if m != nil {
		return m.HighComputingPower
	}
	return 0
}

// Node defines the node
type Node struct {
	Id             string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	DivisionId     string `protobuf:"bytes,2,opt,name=division_id,json=divisionId,proto3" json:"division_id,omitempty"`
	Owner          string `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	ComputingPower uint64 `protobuf:"varint,4,opt,name=computing_power,json=computingPower,proto3" json:"computing_power,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb21c7c329a6c9e, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (m *Node) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Node) GetDivisionId() string {
	if m != nil {
		return m.DivisionId
	}
	return ""
}

func (m *Node) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Node) GetComputingPower() uint64 {
	if m != nil {
		return m.ComputingPower
	}
	return 0
}

// ExtractableComputingPower defines the extractable computing power
type ExtractableComputingPower struct {
	Owner  string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Amount uint64 `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *ExtractableComputingPower) Reset()         { *m = ExtractableComputingPower{} }
func (m *ExtractableComputingPower) String() string { return proto.CompactTextString(m) }
func (*ExtractableComputingPower) ProtoMessage()    {}
func (*ExtractableComputingPower) Descriptor() ([]byte, []int) {
	return fileDescriptor_cdb21c7c329a6c9e, []int{3}
}
func (m *ExtractableComputingPower) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExtractableComputingPower) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExtractableComputingPower.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExtractableComputingPower) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExtractableComputingPower.Merge(m, src)
}
func (m *ExtractableComputingPower) XXX_Size() int {
	return m.Size()
}
func (m *ExtractableComputingPower) XXX_DiscardUnknown() {
	xxx_messageInfo_ExtractableComputingPower.DiscardUnknown(m)
}

var xxx_messageInfo_ExtractableComputingPower proto.InternalMessageInfo

func (m *ExtractableComputingPower) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *ExtractableComputingPower) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func init() {
	proto.RegisterType((*Params)(nil), "tabi.captain_node.v1.Params")
	proto.RegisterType((*Division)(nil), "tabi.captain_node.v1.Division")
	proto.RegisterType((*Node)(nil), "tabi.captain_node.v1.Node")
	proto.RegisterType((*ExtractableComputingPower)(nil), "tabi.captain_node.v1.ExtractableComputingPower")
}

func init() {
	proto.RegisterFile("tabi/captain-node/v1/captain-node.proto", fileDescriptor_cdb21c7c329a6c9e)
}

var fileDescriptor_cdb21c7c329a6c9e = []byte{
	// 518 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x93, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0x86, 0xe3, 0x34, 0x4d, 0x9b, 0xa9, 0x54, 0xc4, 0x36, 0x2a, 0xa6, 0x12, 0x6e, 0x95, 0x4b,
	0x7b, 0x69, 0x42, 0x55, 0x71, 0xe2, 0x04, 0xa1, 0x40, 0x25, 0xd4, 0x46, 0xe1, 0xc6, 0x65, 0xb5,
	0xb6, 0x37, 0xce, 0x4a, 0xeb, 0x1d, 0x6b, 0xbd, 0x76, 0xc2, 0x5b, 0xf0, 0x2e, 0xbc, 0x04, 0xc7,
	0x1e, 0x39, 0xa2, 0xe4, 0x15, 0x78, 0x00, 0xe4, 0xf5, 0x1a, 0x1a, 0xda, 0x9b, 0x67, 0xbf, 0xf9,
	0xbd, 0xff, 0xfc, 0xa3, 0x85, 0x53, 0xc3, 0x42, 0x31, 0x8a, 0x58, 0x66, 0x98, 0x50, 0xe7, 0x0a,
	0x63, 0x3e, 0x2a, 0x2f, 0x36, 0xea, 0x61, 0xa6, 0xd1, 0x20, 0xe9, 0x57, 0x8d, 0x43, 0x07, 0xa8,
	0x05, 0xe5, 0xc5, 0x51, 0x3f, 0xc1, 0x04, 0x6d, 0xc3, 0xa8, 0xfa, 0xaa, 0x7b, 0x07, 0xbf, 0xdb,
	0xd0, 0x9d, 0x30, 0xcd, 0xd2, 0x9c, 0xbc, 0x84, 0xbe, 0x41, 0xc3, 0x24, 0x8d, 0xb0, 0x50, 0x86,
	0x3a, 0x7d, 0xee, 0x7b, 0x27, 0xde, 0x59, 0x67, 0x4a, 0x2c, 0x1b, 0x57, 0x68, 0xec, 0x08, 0x79,
	0x05, 0xcf, 0x52, 0xa1, 0x44, 0x5a, 0xa4, 0x34, 0xc3, 0x05, 0xd7, 0x14, 0x15, 0xcd, 0xb8, 0x16,
	0x18, 0xfb, 0x6d, 0x2b, 0xea, 0x3b, 0x3c, 0xa9, 0xe8, 0xad, 0x9a, 0x58, 0x66, 0x65, 0x6c, 0xf9,
	0xa8, 0x6c, 0xcb, 0xc9, 0x6a, 0xbc, 0x29, 0x7b, 0x01, 0x10, 0xa1, 0xca, 0x0d, 0x53, 0x86, 0x32,
	0xbf, 0x63, 0x3b, 0x7b, 0xcd, 0xc9, 0x1b, 0x72, 0x09, 0x87, 0x51, 0xa1, 0x35, 0x57, 0x86, 0x4a,
	0x5e, 0x72, 0x49, 0x67, 0xa8, 0x69, 0xce, 0x24, 0xf7, 0xb7, 0x6d, 0xeb, 0x81, 0xa3, 0x9f, 0x2a,
	0xf8, 0x1e, 0xf5, 0x67, 0x26, 0x39, 0x79, 0x0d, 0x47, 0x8d, 0x15, 0x55, 0xa4, 0x61, 0xe5, 0x65,
	0x46, 0xe7, 0x28, 0x63, 0xa1, 0x92, 0xdc, 0xef, 0x5a, 0x61, 0x63, 0xf6, 0xc6, 0x36, 0xdc, 0xce,
	0x3e, 0x3a, 0x4c, 0x8e, 0x61, 0x6f, 0xce, 0x64, 0x29, 0x54, 0x42, 0xb9, 0x66, 0xfe, 0x8e, 0xed,
	0x06, 0x77, 0x74, 0xa5, 0x19, 0xf1, 0x61, 0x27, 0x62, 0x52, 0x72, 0x9d, 0xfb, 0xbb, 0x27, 0x5b,
	0x67, 0xbd, 0x69, 0x53, 0x0e, 0xbe, 0x7b, 0xb0, 0xfb, 0x4e, 0x94, 0x22, 0x17, 0xa8, 0xc8, 0x3e,
	0xb4, 0x45, 0x6c, 0x63, 0xee, 0x4d, 0xdb, 0x22, 0x26, 0x7d, 0xd8, 0xb6, 0x13, 0xb8, 0x10, 0xeb,
	0xa2, 0xba, 0xed, 0xde, 0x7a, 0x5c, 0x52, 0xf0, 0x6f, 0x2b, 0x64, 0x08, 0x07, 0x12, 0x17, 0x34,
	0xc2, 0x34, 0x2b, 0x4c, 0x65, 0xca, 0x86, 0xeb, 0x82, 0x7a, 0x2a, 0x71, 0x31, 0x6e, 0x88, 0xcd,
	0xb5, 0xda, 0xf7, 0x5c, 0x24, 0xf3, 0x07, 0x82, 0x3a, 0x2e, 0x52, 0xb1, 0x4d, 0xc5, 0xa0, 0x84,
	0xce, 0x0d, 0xc6, 0xfc, 0x81, 0xe1, 0x63, 0xd8, 0x8b, 0xdd, 0x30, 0x54, 0xd4, 0xbb, 0xef, 0x4d,
	0xa1, 0x39, 0xba, 0xb6, 0x13, 0xe1, 0x42, 0x71, 0x6d, 0x5d, 0xf7, 0xa6, 0x75, 0x41, 0x4e, 0xe1,
	0xc9, 0xe3, 0x66, 0xf7, 0xa3, 0xcd, 0x7b, 0xaf, 0xe1, 0xf9, 0xd5, 0xd2, 0x68, 0x16, 0x19, 0x16,
	0x4a, 0xfe, 0xdf, 0x18, 0x7f, 0xff, 0xed, 0xdd, 0xff, 0xf7, 0x21, 0x74, 0x59, 0x6a, 0x83, 0xaa,
	0x43, 0x74, 0xd5, 0xdb, 0x0f, 0x3f, 0x56, 0x81, 0x77, 0xb7, 0x0a, 0xbc, 0x5f, 0xab, 0xc0, 0xfb,
	0xb6, 0x0e, 0x5a, 0x77, 0xeb, 0xa0, 0xf5, 0x73, 0x1d, 0xb4, 0xbe, 0x9c, 0x27, 0xc2, 0xcc, 0x8b,
	0x70, 0x18, 0x61, 0x3a, 0xaa, 0x1e, 0x90, 0x64, 0x61, 0x6e, 0x3f, 0x46, 0xcb, 0xcd, 0x47, 0x67,
	0xbe, 0x66, 0x3c, 0x0f, 0xbb, 0xf6, 0xfd, 0x5c, 0xfe, 0x09, 0x00, 0x00, 0xff, 0xff, 0xc1, 0x2e,
	0x38, 0xc9, 0x96, 0x03, 0x00, 0x00,
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Callers) > 0 {
		for iNdEx := len(m.Callers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Callers[iNdEx])
			copy(dAtA[i:], m.Callers[iNdEx])
			i = encodeVarintCaptainNode(dAtA, i, uint64(len(m.Callers[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.HalvingEra != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.HalvingEra))
		i--
		dAtA[i] = 0x38
	}
	if m.MaximumNumberOfHoldings != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.MaximumNumberOfHoldings))
		i--
		dAtA[i] = 0x30
	}
	if m.CurrentLevelForSale != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.CurrentLevelForSale))
		i--
		dAtA[i] = 0x28
	}
	if m.ConstantA != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.ConstantA))
		i--
		dAtA[i] = 0x20
	}
	if m.MaximumPowerOnPeriod != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.MaximumPowerOnPeriod))
		i--
		dAtA[i] = 0x18
	}
	if m.MinimumPowerOnPeriod != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.MinimumPowerOnPeriod))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalCountCaptains != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.TotalCountCaptains))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Division) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Division) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Division) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighComputingPower != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.HighComputingPower))
		i--
		dAtA[i] = 0x28
	}
	if m.LowComputingPower != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.LowComputingPower))
		i--
		dAtA[i] = 0x20
	}
	if m.TotalCount != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptainNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComputingPower != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.ComputingPower))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptainNode(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DivisionId) > 0 {
		i -= len(m.DivisionId)
		copy(dAtA[i:], m.DivisionId)
		i = encodeVarintCaptainNode(dAtA, i, uint64(len(m.DivisionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCaptainNode(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExtractableComputingPower) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExtractableComputingPower) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExtractableComputingPower) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintCaptainNode(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintCaptainNode(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCaptainNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovCaptainNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalCountCaptains != 0 {
		n += 1 + sovCaptainNode(uint64(m.TotalCountCaptains))
	}
	if m.MinimumPowerOnPeriod != 0 {
		n += 1 + sovCaptainNode(uint64(m.MinimumPowerOnPeriod))
	}
	if m.MaximumPowerOnPeriod != 0 {
		n += 1 + sovCaptainNode(uint64(m.MaximumPowerOnPeriod))
	}
	if m.ConstantA != 0 {
		n += 1 + sovCaptainNode(uint64(m.ConstantA))
	}
	if m.CurrentLevelForSale != 0 {
		n += 1 + sovCaptainNode(uint64(m.CurrentLevelForSale))
	}
	if m.MaximumNumberOfHoldings != 0 {
		n += 1 + sovCaptainNode(uint64(m.MaximumNumberOfHoldings))
	}
	if m.HalvingEra != 0 {
		n += 1 + sovCaptainNode(uint64(m.HalvingEra))
	}
	if len(m.Callers) > 0 {
		for _, s := range m.Callers {
			l = len(s)
			n += 1 + l + sovCaptainNode(uint64(l))
		}
	}
	return n
}

func (m *Division) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptainNode(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovCaptainNode(uint64(m.Level))
	}
	if m.TotalCount != 0 {
		n += 1 + sovCaptainNode(uint64(m.TotalCount))
	}
	if m.LowComputingPower != 0 {
		n += 1 + sovCaptainNode(uint64(m.LowComputingPower))
	}
	if m.HighComputingPower != 0 {
		n += 1 + sovCaptainNode(uint64(m.HighComputingPower))
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCaptainNode(uint64(l))
	}
	l = len(m.DivisionId)
	if l > 0 {
		n += 1 + l + sovCaptainNode(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptainNode(uint64(l))
	}
	if m.ComputingPower != 0 {
		n += 1 + sovCaptainNode(uint64(m.ComputingPower))
	}
	return n
}

func (m *ExtractableComputingPower) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovCaptainNode(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovCaptainNode(uint64(m.Amount))
	}
	return n
}

func sovCaptainNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCaptainNode(x uint64) (n int) {
	return sovCaptainNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptainNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCountCaptains", wireType)
			}
			m.TotalCountCaptains = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCountCaptains |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumPowerOnPeriod", wireType)
			}
			m.MinimumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumPowerOnPeriod", wireType)
			}
			m.MaximumPowerOnPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumPowerOnPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConstantA", wireType)
			}
			m.ConstantA = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConstantA |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLevelForSale", wireType)
			}
			m.CurrentLevelForSale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentLevelForSale |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaximumNumberOfHoldings", wireType)
			}
			m.MaximumNumberOfHoldings = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaximumNumberOfHoldings |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HalvingEra", wireType)
			}
			m.HalvingEra = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HalvingEra |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptainNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callers = append(m.Callers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCaptainNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Division) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptainNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Division: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Division: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptainNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowComputingPower", wireType)
			}
			m.LowComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighComputingPower", wireType)
			}
			m.HighComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptainNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptainNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptainNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DivisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptainNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DivisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptainNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputingPower", wireType)
			}
			m.ComputingPower = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputingPower |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptainNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExtractableComputingPower) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCaptainNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExtractableComputingPower: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExtractableComputingPower: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCaptainNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCaptainNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCaptainNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCaptainNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCaptainNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCaptainNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCaptainNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCaptainNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCaptainNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCaptainNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCaptainNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCaptainNode = fmt.Errorf("proto: unexpected end of group")
)
